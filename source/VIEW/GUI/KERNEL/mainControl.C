// $Id: mainControl.C,v 1.22.4.9 2002/12/04 23:10:46 amoll Exp $

// this is required for QMenuItem
#define INCLUDE_MENUITEM_DEF

#include <BALL/VIEW/GUI/KERNEL/mainControl.h>
#include <BALL/VIEW/GUI/WIDGETS/modularWidget.h>
#include <BALL/KERNEL/system.h>

#include <qapplication.h>
#include <qwidget.h>
#include <qmenubar.h>
#include <qpopupmenu.h>
#include <qstatusbar.h>

using std::istream;
using std::ostream;
using std::endl;

namespace BALL
{
	namespace VIEW
	{

	  MainControl::PreferencesError::PreferencesError(const char* file, int line, const string& data)
			throw()
			: Exception::GeneralException(file, line, string("PreferencesError"), data)
		{
    }
  
		MainControl::MainControl(QWidget* parent, const char* name, String inifile)
			throw()
			:	QMainWindow(parent, name),
				selection_(),
				composite_map_(),
				descriptor_map_(),
				descriptors_(),
				main_control_preferences_(0),
				preferences_dialog_(0),
				preferences_id_(-1)
		{
			// read the preferences
			preferences_.setFilename(inifile);
			preferences_.read();

			connect(qApp,	SIGNAL(aboutToQuit()), this, SLOT(aboutToExit()));
		}
		
		MainControl::MainControl(const MainControl& main_control)
			throw()
			:	QMainWindow(0, ""),
				ConnectionObject(main_control),
				Embeddable(main_control),
				selection_(),
				composite_map_(),
				descriptor_map_(),
				descriptors_(),
				main_control_preferences_(0),
				preferences_dialog_(0),
				preferences_id_(-1)
		{
		}
		
		MainControl::~MainControl()
			throw()
		{
			#ifdef BALL_VIEW_DEBUG
				Log.info() << "Destructing object " << (void *)this << " of class " << RTTI::getName<MainControl>() << endl;
			#endif 

			destroy();
		}

		QPopupMenu* MainControl::initPopupMenu(int ID)
			throw()
		{
			QPopupMenu* menu = 0;
			QMenuItem* item = menuBar()->findItem(ID);
			if ((item == 0) || (item->popup() == 0))
			{
				menu = new QPopupMenu(this);
				CHECK_PTR(menu);

				connect(menu, SIGNAL(aboutToShow()), this, SLOT(checkMenus()));

				#ifdef BALL_VIEW_DEBUG
					Log.info() << "new menu entry: " << ID << endl;	
				#endif
				int max_id = menuBar()->count();
				switch (ID)
				{
					case FILE:
						menuBar()->insertItem("&File", menu, FILE, 0);
						break;
   				case FILE_IMPORT:
						initPopupMenu(MainControl::FILE)->insertItem("&Import File", menu, FILE_IMPORT);
						break;
					case EDIT:
						menuBar()->insertItem("&Edit", menu, EDIT, (1 <= max_id) ? 1 : -1);
						break;
					case BUILD:
						menuBar()->insertItem("&Build", menu, BUILD, (2 <= max_id) ? 2 : -1);
						break;
					case DISPLAY:
						menuBar()->insertItem("&Display", menu, DISPLAY, (3 <= max_id) ? 3 : -1);
						break;
					case TOOLS:
						menuBar()->insertItem("&Tools", menu, TOOLS, (4 <= max_id) ? 4 : -1);
						break;
					case USER:
						menuBar()->insertItem("&User", menu, USER, (5 <= max_id) ? 5 : -1);
						break;

					case HELP:
						menuBar()->insertSeparator();
						menuBar()->insertItem("&Help", menu, HELP, -1);
						break;
					default:
						delete menu;
						menu = 0;
				}
			}
			else 
			{
				// return the existing popup menu
				menu = item->popup();
			}

			return menu;
		}

		void MainControl::clear()
			throw()
		{
			list<CompositeDescriptor *>::iterator it = descriptors_.begin();
			for (; it != descriptors_.end(); ++it)
			{
				delete *it;
			}

			descriptors_.destroy();
			composite_map_.destroy();
			descriptor_map_.destroy();
			selection_.clear();
		}
			
		void MainControl::destroy()
			throw()
		{
			clear();
		}

		void MainControl::show()
		{
			#ifdef BALL_VIEW_DEBUG
        Log.info() << "MainControl::show()  list.size() = " << modular_widgets_.size() << endl;
			#endif

			// create own preferences dialog
			preferences_dialog_ = new Preferences(this);

			if (preferences_dialog_ == 0)
			{
				throw PreferencesError(__FILE__, __LINE__, "memory allocation failed for preferences dialog.");
			}

			// establish connection 
			connect(preferences_dialog_, SIGNAL(applyButtonPressed()), this, SLOT(applyPreferencesTab()));

			// initialize own preferences tab
			initializePreferencesTab(*preferences_dialog_);

			// initialize all modular widgets 
			List<ModularWidget*>::Iterator it = modular_widgets_.begin(); 
			for (; it != modular_widgets_.end(); ++it)
			{
				registerConnectionObject(**it);
				(*it)->initializeWidget(*this);
				(*it)->initializePreferencesTab(*preferences_dialog_);
			}

			// check own preferences 
			preferences_dialog_->fetchPreferences(preferences_);

			// fetch own preferences tab
			fetchPreferences(preferences_);

			// apply on own preferences tab
			applyPreferences(*preferences_dialog_);

			// check menu entries, fetch and apply preferences
			for (it = modular_widgets_.begin(); it != modular_widgets_.end(); ++it)
			{
				(*it)->checkMenu(*this);
				(*it)->fetchPreferences(preferences_);
				(*it)->applyPreferences(*preferences_dialog_);
			}

			// own menu entries
			insertPopupMenuSeparator(MainControl::FILE);
			insertMenuEntry(MainControl::FILE, "E&xit", qApp, SLOT(quit()), CTRL+Key_X);	
			
			// if the preferences dialog has any tabs then show it
			if (preferences_dialog_->hasTabs())
			{
				initPopupMenu(MainControl::DISPLAY)->setCheckable(true);
				
				preferences_id_ = insertMenuEntry(MainControl::DISPLAY, 
																					"&Preferences", 
																					preferences_dialog_, 
																					SLOT(openDialog()), CTRL+Key_P);
			}

			QMainWindow::show();
		}

		void MainControl::checkMenus()
		{
			// preferences dialog not empty
			if (preferences_dialog_->hasTabs())
			{
				menuBar()->setItemChecked(preferences_id_, preferences_dialog_->isVisible());			
			}

			// checks all modular widgets 
			List<ModularWidget*>::Iterator it = modular_widgets_.begin(); 
			for (it = modular_widgets_.begin(); it != modular_widgets_.end(); ++it)
			{
				(*it)->checkMenu(*this);
			}
		}

		void MainControl::applyPreferencesTab()
		{
			// apply on own preferences tab
			applyPreferences(*preferences_dialog_);

			// checks all modular widgets 
			List<ModularWidget*>::Iterator it = modular_widgets_.begin(); 
			for (it = modular_widgets_.begin(); it != modular_widgets_.end(); ++it)
			{
				(*it)->applyPreferences(*preferences_dialog_);
			}
		}

		void MainControl::aboutToExit()
		{
			// finalizes all modular widgets
			List<ModularWidget*>::Iterator it = modular_widgets_.begin(); 
			for (it = modular_widgets_.begin(); it != modular_widgets_.end(); ++it)
			{
				(*it)->writePreferences(preferences_);
				(*it)->finalizePreferencesTab(*preferences_dialog_);
				(*it)->finalizeWidget(*this);
			}

			modular_widgets_.clear();

			//
			// write the preferences
			//
			preferences_dialog_->writePreferences(preferences_);

			// write default preferences 
			writePreferences(preferences_);

			// finalize own preferences tab
			finalizePreferencesTab(*preferences_dialog_);

			delete preferences_dialog_;
			preferences_dialog_ = 0;
		}

		bool MainControl::remove(const Composite& composite, bool sent_message)
			throw()
		{
			ListIteratorHashMap::Iterator map_iterator = composite_map_.find((void*)&composite);

			if (map_iterator != composite_map_.end())
			{
				if (sent_message)
				{
					// send a message that the composite descriptor
					// will be deleted
					RemovedCompositeMessage *message = new RemovedCompositeMessage;
					message->setComposite(composite);
					message->setDeletable(true);
					notify_(message);
				}
 
				// delete all information concerning the composite
				CompositeDescriptor* descriptor = *(map_iterator->second);

				// remove Iterator from DescriptorList
				descriptors_.erase(map_iterator->second);

				// remove Composite from Composite2CompositeDescriptorIterator HashMap
				composite_map_.erase((void*)&composite);
				
				// remove CompositeDescriptor from CompositeDescriptor2CompositeDescriptorIterator HashMap
				descriptor_map_.erase((void *)descriptor);

				// delete CompositeDescriptor
				delete descriptor;

				return true;
			}

			return false;
		}

		bool MainControl::remove(const CompositeDescriptor& composite_descriptor)
			throw()
		{
			ListIteratorHashMap::Iterator map_iterator = descriptor_map_.find((void*)&composite_descriptor);

			if (map_iterator != descriptor_map_.end())
			{
				 composite_map_.erase((void*)composite_descriptor.getComposite());
				descriptor_map_.erase((void*)&composite_descriptor);
				delete (CompositeDescriptor*)map_iterator->first;
				descriptors_.erase(map_iterator->second);

				return true;
			}

			return false;
		}

		bool MainControl::setName(const Composite& composite, const String& s)
			throw()
		{
			ListIteratorHashMap::Iterator map_iterator = 
				composite_map_.find((void*)&composite);

			if (map_iterator != composite_map_.end())
			{
				(*map_iterator->second)->setName(s);

				return true;
			}

			return false;
		}

		String* MainControl::getName(const Composite& composite)
			throw()
		{
			ListIteratorHashMap::Iterator map_iterator = composite_map_.find((void*)&composite);

			if (map_iterator != composite_map_.end())
			{
				return &((*map_iterator->second)->getName());
			}

			return 0;  
		}

		CompositeDescriptor* MainControl::getDescriptor(const String& name)
			throw()
		{
			list<CompositeDescriptor *>::iterator it = descriptors_.begin();

			for (; it != descriptors_.end(); ++it)
			{
				if ((*it)->getName() == name)
				{
					return (*it);
				}
			}
			
			return 0;
		}

		bool MainControl::setCenter(const Composite& composite, const Vector3& v)
			throw()
		{
			ListIteratorHashMap::Iterator map_iterator = composite_map_.find((void*)&composite);

			if (map_iterator != composite_map_.end())
			{
				(*map_iterator->second)->setCenter(v);
				return true;
			}

			return false;
		}

		Vector3* MainControl::getCenter(const Composite& composite)
			throw()
		{
			ListIteratorHashMap::Iterator map_iterator =
				composite_map_.find((void*)&composite);

			if (map_iterator != composite_map_.end())
			{
				return &(*map_iterator->second)->getCenter();
			}

			return 0;
		}

		CompositeDescriptor* MainControl::getDescriptor(const Vector3& center)
			throw()
		{
			list<CompositeDescriptor *>::iterator it = descriptors_.begin();

			for (; it != descriptors_.end();++it)
			{
				if ((*it)->getCenter() == center)
				{
					return (*it);
				}
			}
			
			return 0;
		}

		bool MainControl::update(const Composite& composite)
			throw()
		{
			ListIteratorHashMap::Iterator map_iterator = composite_map_.find((void*)&composite);

			if (map_iterator != composite_map_.end())
			{
				(*map_iterator->second)->update();
				return true;
			}

			return false;
		}

		void MainControl::updateAll()
			throw()
		{
			list<CompositeDescriptor *>::iterator it = descriptors_.begin();

			for (; it != descriptors_.end();++it)
			{
				(*it)->update();
			}

			// update scene
			SceneMessage *scene_message = new SceneMessage;
			scene_message->updateOnly();
			scene_message->setDeletable(true);
			notify_(scene_message); 
		}

		void MainControl::insert(Composite* composite, const String& name, const Vector3& center)
			throw()
		{
			if (composite == 0)
			{
				return;
			}

			// is already inserted => remove it and sent a message
			if (isInserted(*composite))
			{
				remove(*composite, true);
			}

			// create a new composite descriptor and enable the self deletion mechanism
			// for the composite
			List<CompositeDescriptor*>::Iterator list_iterator = descriptors_.end();

			CompositeDescriptor* composite_descriptor = new CompositeDescriptor();

			composite_descriptor->setComposite(composite, true);
			composite_descriptor->setName(name);
			composite_descriptor->setCenter(center);

			descriptors_.push_back(composite_descriptor);
			list_iterator = descriptors_.end();
			list_iterator--;

			 composite_map_.insert(ListIteratorHashMap::ValueType((void *)composite, list_iterator));
			descriptor_map_.insert(ListIteratorHashMap::ValueType((void *)composite_descriptor, list_iterator));
 		}	

		void MainControl::onNotify(Message *message)
			throw()
    {
			if (RTTI::isKindOf<WindowMessage>(*message))
			{
				WindowMessage *window_message = RTTI::castTo<WindowMessage>(*message);
				statusBar()->message(window_message->getStatusBar().c_str());
				
				QWidget::update();
			}
			else if (RTTI::isKindOf<NewCompositeMessage>(*message))
			{
				NewCompositeMessage* new_message = RTTI::castTo<NewCompositeMessage>(*message);
				insert(new_message->getComposite(), new_message->getCompositeName());
 			}
			else if (RTTI::isKindOf<RemovedCompositeMessage>(*message))
			{
				RemovedCompositeMessage *composite_message = RTTI::castTo<RemovedCompositeMessage>(*message);
				remove(*composite_message->getComposite(), false);
			}
			else if (RTTI::isKindOf<ChangedCompositeMessage>(*message))
			{
				ChangedCompositeMessage *composite_message = RTTI::castTo<ChangedCompositeMessage>(*message);
				update(composite_message->getComposite()->getRoot());
			}
			else if (RTTI::isKindOf<GeometricObjectSelectionMessage>(*message))
			{
				GeometricObjectSelectionMessage* selection_message = RTTI::castTo<GeometricObjectSelectionMessage>(*message);
				selectComposites_(*selection_message);
			}
			else if(RTTI::isKindOf<CompositeSelectedMessage>(*message))
			{
				CompositeSelectedMessage * selection_message = RTTI::castTo<CompositeSelectedMessage>(*message);
				if (selection_message->selected_ == selection_.has(selection_message->composite_)) return;
				if (selection_message->selected_) 
				{
					selection_.insert(selection_message->composite_);
				}
				else
				{
					selection_.erase(selection_message->composite_);
				}
								
				// sending of scene message and geometric object selector is done in MolecularProperties, because
				// ObjectSelector is part of MOLVIEW
			}
    }

		bool MainControl::isInserted(const Composite& composite) const
			throw()
		{
			return (composite_map_.find((void*)&composite) != composite_map_.end());
		}

		bool MainControl::isInserted(const CompositeDescriptor& composite_descriptor) const
			throw()
		{
			return (descriptor_map_.find((void*)&composite_descriptor) != descriptor_map_.end());
		}

		bool MainControl::isValid() const
			throw()
		{
			List<CompositeDescriptor*>::ConstIterator it = descriptors_.begin();

			for ( ; it != descriptors_.end();++it)
			{
				if (!(*it)->isValid())
				{
					return false;
				}
			}

			return true;
		}

		void MainControl::dump(ostream& s, Size depth) const
			throw()
		{
			BALL_DUMP_STREAM_PREFIX(s);

			BALL_DUMP_DEPTH(s, depth);
			BALL_DUMP_HEADER(s, this, this);

			List<CompositeDescriptor*>::ConstIterator it = descriptors_.begin();

			for ( ; it != descriptors_.end(); ++it)
			{
				(*it)->dump(s, depth + 1);
			}

			BALL_DUMP_STREAM_SUFFIX(s);     
		}

		void MainControl::read(istream &/* s */)
			throw()
		{
			throw ::BALL::Exception::NotImplemented(__FILE__, __LINE__);
		}

		void MainControl::write(ostream &/*s*/) const
			throw()
		{
			throw ::BALL::Exception::NotImplemented(__FILE__, __LINE__);
		}

		CompositeDescriptor*  MainControl::insert_(const Composite& composite, const String& s, const Vector3& v)
			throw()
		{
			if (composite_map_.has((void *)&composite))
			{
				return 0;
			}

			List<CompositeDescriptor*>::Iterator list_iterator = descriptors_.end();

			CompositeDescriptor* composite_descriptor = new CompositeDescriptor();
			composite_descriptor->setComposite(&composite);
			composite_descriptor->setName(s);
			composite_descriptor->setCenter(v);

			descriptors_.push_back(composite_descriptor);
			list_iterator = descriptors_.end();
			list_iterator--;

			composite_map_.insert(ListIteratorHashMap::ValueType((void *)&composite, list_iterator));
			descriptor_map_.insert(ListIteratorHashMap::ValueType((void *)composite_descriptor, list_iterator));

			return composite_descriptor;
		}

		CompositeDescriptor* MainControl::insert_(CompositeDescriptor& composite_descriptor, bool deep)
			throw()
		{
			if (descriptor_map_.has((void*)&composite_descriptor) && !deep)
			{
				return 0;
			}

			List<CompositeDescriptor*>::Iterator list_iterator;

			CompositeDescriptor* new_composite_descriptor 
				= (CompositeDescriptor*)composite_descriptor.create(deep);

			descriptors_.push_back(new_composite_descriptor);
			list_iterator = descriptors_.end();
			list_iterator--;

			composite_map_.insert(ListIteratorHashMap::ValueType((void*)new_composite_descriptor->getComposite(), list_iterator));

			descriptor_map_.insert(ListIteratorHashMap::ValueType((void*)new_composite_descriptor, list_iterator));

			return new_composite_descriptor;
		}

		// VIEW automatic module registration
		MainControl* MainControl::getMainControl(const QObject* object)
			throw()
		{
			QObject* parent = object->parent();
			while ((parent != 0) && (parent->parent() != 0))
			{
				parent = parent->parent();
			}

			MainControl* mc = 0;
			if (parent != 0)
			{
				// check whether the top-level widget
				// is a MainControl
				mc = dynamic_cast<MainControl*>(parent);
			}
			else 
			{
				// try whether the widget itself is the main control
				mc = dynamic_cast<MainControl*>(const_cast<QObject*>(object));
			}

			#ifdef BALL_DEBUG_VIEW
				Log << "Top level widget : mc = " << mc << endl;
			#endif

			return mc;
		}
		
		int MainControl::current_id_ = 15000;

    int MainControl::insertMenuEntry(int ID, const String& name, const QObject* receiver, const char* slot, int accel, int entry_ID)
			throw()
		{
			QMenuBar* menu_bar = menuBar();
			if (menu_bar != 0)
			{
				// enable the corresponding popup menu
				menu_bar->setItemEnabled(ID, true);
				//
				QPopupMenu* popup = initPopupMenu(ID);
				if (popup == 0)
				{
					Log.error() << "MainControl::insertMenuEntry: cannot find popup menu for ID " << ID << endl;
				}
				else
				{
					// insert the menu entry
					if (entry_ID == -1)
					{
						entry_ID = getNextID_();
					}

					popup->insertItem(name.c_str(), receiver, slot, accel, entry_ID);
					return entry_ID;
				}
			}

			return -1;
		}
		
		void MainControl::insertPopupMenuSeparator(int ID)
			throw()
		{
			QMenuBar* menu_bar = menuBar();
			if (menu_bar != 0)
			{
				// enable the corresponding popup menu
				menu_bar->setItemEnabled(ID, true);
				//
				QPopupMenu* popup = initPopupMenu(ID);
				if (popup == 0)
				{
					Log.error() << "MainControl::insertMenuEntry: cannot find popup menu for ID " << ID << endl;
				}
				else
				{
					popup->insertSeparator();
				}
			}
		}

		void MainControl::removeMenuEntry
			(int /* ID */, const String& /* name */, 
			 const QObject* /* receiver */, const char* /* slot */, 
			 int /* accel */, int /* entry_ID */)
			throw()
		{
			// ?????
		}

		void MainControl::initializePreferencesTab(Preferences &preferences)
			throw()
		{
			main_control_preferences_ = new MainControlPreferences();
			CHECK_PTR(main_control_preferences_);

			preferences.insertTab(main_control_preferences_, "General");
 		}

		void MainControl::finalizePreferencesTab(Preferences &preferences)
			throw()
		{
			if (main_control_preferences_ != 0)
			{
				preferences.removeTab(main_control_preferences_);
		
				delete main_control_preferences_;
				main_control_preferences_ = 0;
			}
		}

		void MainControl::applyPreferences(Preferences & /* preferences */)
			throw()
		{
			if (main_control_preferences_ != 0)
			{
				QApplication::setStyle(main_control_preferences_->getStyle());
				QWidget::update();
			}
		}

		void MainControl::fetchPreferences(INIFile &inifile)
			throw()
		{
			// 
			// the geometry of the main window
			//
			int x_pos = x();
			int y_pos = y();
			int w = 640;
			int h = 480;
			if (inifile.hasEntry("WINDOWS", "Main::x"))
			{
				x_pos = inifile.getValue("WINDOWS", "Main::x").toInt();
			}
			if (inifile.hasEntry("WINDOWS", "Main::y"))
			{
				y_pos = inifile.getValue("WINDOWS", "Main::y").toInt();
			}
			if (inifile.hasEntry("WINDOWS", "Main::height"))
			{
				h = inifile.getValue("WINDOWS", "Main::height").toInt();
			}
			if (inifile.hasEntry("WINDOWS", "Main::width"))
			{
				w = inifile.getValue("WINDOWS", "Main::width").toInt();
			}
			setGeometry(x_pos, y_pos, w, h);
			
			// the default preferences tab (if existent)
			if (main_control_preferences_ != 0)
			{
				main_control_preferences_->fetchPreferences(inifile);
			}
		}

		void MainControl::writePreferences(INIFile &inifile)
			throw()
		{
			// the main window position
			inifile.insertValue ("WINDOWS", "Main::x", String(x()));
			inifile.insertValue ("WINDOWS", "Main::y", String(y()));
			inifile.insertValue ("WINDOWS", "Main::width", String(width()));
			inifile.insertValue ("WINDOWS", "Main::height", String(height()));

			// the default preferences tab (if existent)
			if (main_control_preferences_ != 0)
			{
				main_control_preferences_->writePreferences(inifile);
			}
			inifile.write();
		}

		void MainControl::addModularWidget(ModularWidget* widget)
			throw()
		{
			#ifdef BALL_DEBUG_VIEW
				Log << "MainControl::addModularWidget(" << widget << ")" << endl;
			#endif
			modular_widgets_.push_back(widget);
			widget->registerThis();
		}

		void MainControl::removeModularWidget(ModularWidget* widget)
			throw()
		{
			#ifdef BALL_DEBUG_VIEW
				Log.info() << "MainControl::removeModularWidget(" << widget << ")" << endl;
			#endif
			modular_widgets_.remove(widget);
		}

		void MainControl::selectComposites_(GeometricObjectSelectionMessage& message)
			throw()
		{
			selection_.clear();		
			// wird GeometricObject list
			List<Composite*>& objects = const_cast<List<Composite*>&>(message.getSelection());
			List<Composite*>::Iterator it = objects.begin();

			Size nr = 0;
			for (; it != objects.end(); it++)
			{
				if (!RTTI::isKindOf<GeometricObject>(*(*it)->getParent()) &&
						!selection_.has((*it)->getParent())) 
				{	
					selection_.insert((*it)->getParent());;
					nr++;
				}				
			}
			NewSelectionMessage* new_message = new NewSelectionMessage;
			notify_(new_message);
			Log.info() << "Selected " + String(nr) + " items."<< std::endl;
		}
 
		const HashSet<Composite*>& MainControl::getSelection() const
			throw()
		{
			return selection_;
		}
  
		System* MainControl::getSelectedSystem()
			throw()
		{
			System* system = NULL;
			HashSet<Composite*>::Iterator it = selection_.begin();
			for (; it != selection_.end(); it++)
			{
				if (*it == 0) continue;
				if (RTTI::isKindOf<System>(**it))
				{
					if (system != 0) return 0;
					system = (System*) *it;
				}
			}
			return system;
		}

		void MainControl::selectComposite(Composite* composite, bool state)
			throw()
		{
			if (state)
			{
				selection_.insert(composite);
			}
			else			
			{
				selection_.erase(composite);			
			}				
		}			

#ifdef BALL_NO_INLINE_FUNCTIONS
#	include <BALL/VIEW/GUI/KERNEL/mainControl.iC>
#endif

	} // namespace VIEW

} // namespace BALL
