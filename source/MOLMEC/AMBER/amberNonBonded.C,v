head	1.1;
access;
symbols;
locks
	oliver:1.1; strict;
comment	@ * @;


1.1
date	99.06.14.15.23.39;	author oliver;	state Exp;
branches;
next	;


desc
@First try - still some bugs in electrostatics!
@


1.1
log
@Initial revision
@
text
@// $Id: amberNonBonded.C,v,v 1.1 1999/08/26 08:02:44 oliver Exp $

#include <BALL/MOLMEC/AMBER/amberNonBonded.h>
#include <BALL/MOLMEC/AMBER/amber.h>
#include <BALL/MOLMEC/COMMON/forceField.h>
#include <BALL/MOLMEC/COMMON/support.h>

namespace Ball {

	const char* AmberNonBonded::error_message_[] =
	{
		"Unknown error.",
		"Not implemented."
	};
	 

	// default constructor
	AmberNonBonded::AmberNonBonded()
		:	ForceFieldComponent()
	{	
		// set component name
		setName( "Amber NonBonded" );

		setForceField(0);	

	}


	// constructor
	AmberNonBonded::AmberNonBonded(ForceField* force_field)
		:	ForceFieldComponent(force_field)
	{
		// set component name
		setName( "Amber NonBonded" );

		// setForceField(force_field);

	}


	// copy constructor
	AmberNonBonded::AmberNonBonded(const AmberNonBonded&	component, bool clone_deep)
		:	ForceFieldComponent(component, clone_deep)
	{
		non_bonded_ = component.non_bonded_;
		number_of_1_4_ = component.number_of_1_4_;

		electrostatic_energy_ = component.electrostatic_energy_;
		vdw_energy_ = component.vdw_energy_;
		algorithm_type_ = component.algorithm_type_;

		cut_off_ = component.cut_off_;
		cut_off_electrostatic_ = component.cut_off_electrostatic_;
		cut_off_vdw_ = component.cut_off_vdw_;
		scaling_vdw_1_4_ = component.scaling_vdw_1_4_;
		scaling_electrostatic_1_4_ = component.scaling_electrostatic_1_4_;
	}

	// destructor
	AmberNonBonded::~AmberNonBonded()
	{
	}

	// This function determines the most efficient way to calculate all non-bonded atom pairs
	// that depends on the number of atoms of the system.
	// The function return value 0 if the number of atoms is so small that the brute force all against
	// all comparison is the most efficient way. Otherwise it returns 1. 

	int	AmberNonBonded::determineMethodOfAtomPairGeneration()
	{
		int algorithm_type = 1;
		if (force_field_->getAtoms().size() < 200) 
		{ 
			algorithm_type = 0;
		} 
		return algorithm_type;
	}


	// setup the internal datastructures for the component
	bool AmberNonBonded::setup()
	{
		if (getForceField() == 0) 
		{
			Log.level(LogStream::ERROR) << "AmberNonBonded::setup(): component not bound to a force field" << endl;
			return false;
		}

		// clear vector of non-bonded atom pairs
		non_bonded_.clear();
 
		// Set the options for the non-bonded atom pairs

		getForceField()->options.setDefaultReal(AmberFF::Option::NONBONDED_CUTOFF, AmberFF::Default::NONBONDED_CUTOFF);
		cut_off_ = getForceField()->options.getReal(AmberFF::Option::NONBONDED_CUTOFF);

		getForceField()->options.setDefaultReal(AmberFF::Option::ELECTROSTATIC_CUTOFF, AmberFF::Default::ELECTROSTATIC_CUTOFF);
		cut_off_electrostatic_ = getForceField()->options.getReal(AmberFF::Option::ELECTROSTATIC_CUTOFF);

		getForceField()->options.setDefaultReal(AmberFF::Option::VDW_CUTOFF, AmberFF::Default::VDW_CUTOFF);
		cut_off_vdw_ = getForceField()->options.getReal(AmberFF::Option::VDW_CUTOFF);

		getForceField()->options.setDefaultReal(AmberFF::Option::SCALING_ELECTROSTATIC_1_4,AmberFF::Default::SCALING_ELECTROSTATIC_1_4);
		scaling_electrostatic_1_4_ = getForceField()->options.getReal(AmberFF::Option::SCALING_ELECTROSTATIC_1_4);

		getForceField()->options.setDefaultReal(AmberFF::Option::SCALING_VDW_1_4,AmberFF::Default::SCALING_VDW_1_4);
		scaling_vdw_1_4_ = getForceField()->options.getReal(AmberFF::Option::SCALING_VDW_1_4);

		FFPSLennardJones van_der_waals;
		bool result = van_der_waals.extractSection(getForceField()->getParameters(), "LennardJones");

		if (result == false) 
		{
			Log.level(LogStream::ERROR) << "cannot find section LennardJones" << endl;
			return false;
		}

		// Determine the most efficient way to calculate all non bonded atom pairs
		algorithm_type_ = determineMethodOfAtomPairGeneration();

		// Calculate all non bonded atom pairs
		ForceField::PairVector atom_pair_vector;
		Size number_of_non_bonded_interactions = MolmecSupport::calculateNonBondedAtomPairs
																								(atom_pair_vector, getForceField()->getAtoms(), 
																								 getForceField()->periodic_boundary.getBox(),
																								 cut_off_, force_field_->periodic_boundary.isEnabled(), algorithm_type_); 

		// Reserve space for non-bonded vector
		non_bonded_.reserve(number_of_non_bonded_interactions + (Size)(number_of_non_bonded_interactions / 5));

		// Build the vector "non_bonded_" with the atom pairs and parameters
		buildVectorOfNonBondedAtomPairs(atom_pair_vector, van_der_waals);

		return true;
	}


	// Build a vector of non-bonded atom pairs with the vdw parameters 
	// The vector starts with 1-4 interactions
	void AmberNonBonded::buildVectorOfNonBondedAtomPairs
		(const vector< pair<Atom*, Atom*> >& atom_vector,
		 const FFPSLennardJones& lennard_jones)
	{
		// bool vector for storing torsion information
		vector<bool> is_torsion;
		is_torsion.reserve(atom_vector.size());

		// Iterate over all atom pairs in atom_vector and test if the atoms build a torsion
		vector< pair <Atom*, Atom*> >::const_iterator pair_it = atom_vector.begin();

		for ( ; pair_it != atom_vector.end(); ++pair_it) 
		{
			if (pair_it->first->isVicinal(*pair_it->second)) 
			{
				is_torsion.push_back(true);
			}
			else 
			{
				is_torsion.push_back(false);
			}
		}

		vector< bool >::iterator bool_it = is_torsion.begin(); 
		FFPSLennardJones::LennardJones tmp;
		Atom*	atom1;
		Atom* atom2;
		Atom::Type	type_atom1;
		Atom::Type  type_atom2;

		// Iterate and search torsions, fill the atom pairs that have a torsion in non_bonded_

		for (pair_it = atom_vector.begin(); pair_it != atom_vector.end(); ++pair_it, ++bool_it) 
		{
			if (*bool_it) 
			{
				atom1 = pair_it->first;
				atom2 = pair_it->second;
				type_atom1 = atom1->getType();
				type_atom2 = atom2->getType();
				tmp.atom1 = atom1;
				tmp.atom2 = atom2;

				if (lennard_jones.hasParameters(type_atom1, type_atom2)) 
				{
					lennard_jones.assignParameters(tmp.values, type_atom1, type_atom2);				
				} else {
					Log.level(LogStream::ERROR) << "cannot find vdw parameters for:"
						<< getForceField()->getParameters().getAtomTypes().getTypeName(type_atom1) << "-"
						<< getForceField()->getParameters().getAtomTypes().getTypeName(type_atom2) << endl;
					tmp.values.A = 0;
					tmp.values.B = 0;
				}

				non_bonded_.push_back(tmp);
			}
		}

		// Determine and set the number of 1-4 interactions (torsions)
		number_of_1_4_ = non_bonded_.size();

		// Iterate and search non torsions, fill them in the vector non_bonded_
		bool_it = is_torsion.begin();
 
		for ( pair_it = atom_vector.begin(); pair_it != atom_vector.end(); ++pair_it, ++bool_it) 
		{
			if (!(*bool_it)) 
			{
				atom1 = pair_it->first;
				atom2 = pair_it->second;

				if (!atom1->isGeminal(*atom2))
				{
					type_atom1 = atom1->getType();
					type_atom2 = atom2->getType();
					tmp.atom1 = atom1;
					tmp.atom2 = atom2;

					if (lennard_jones.hasParameters(type_atom1,type_atom2)) 
					{
						lennard_jones.assignParameters(tmp.values, type_atom1, type_atom2);
					} else {
						Log.level(LogStream::ERROR) << "cannot find Lennard Jones parameters for:"
							<< getForceField()->getParameters().getAtomTypes().getTypeName(type_atom1) << "-"
							<< getForceField()->getParameters().getAtomTypes().getTypeName(type_atom2) << endl;
						tmp.atom1 = atom1;
						tmp.atom2 = atom2;
						tmp.values.A = 0;
						tmp.values.B = 0;
					}
				} else {
					tmp.atom1 = atom1;
					tmp.atom2 = atom2;
					tmp.values.A = 0;
					tmp.values.B = 0;
				}
				non_bonded_.push_back(tmp);
			}
		}
	}

	inline void calculateVdWAndElectrostatics
		(float distance_2, float& cut_off_electrostatic_2, float cut_off_vdw_2,
		 float& electrostatic_energy, float& vdw_energy)
	{
		distance_2 = difference.getSquareLength();

		if (distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) 
		{
			float inverse_distance_2 = 1/distance_2;
			electrostatic_energy += ((*it).atom1->getCharge() * (*it).atom2->getCharge()) * sqrt(inverse_distance_2);

			if (distance_2 <= cut_off_vdw_2) 
			{
				inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
				float tmp_energy = inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B); 
				//cout << "DATA:  d = " << sqrt(distance_2) << "   A = " << it->values.A << "   B = " << it->values.B << endl;
				//cout << "VdW1-4(" << it->atom1->getName() << "-" << it->atom2->getName() << "): " << tmp_energy << endl;
				vdw_energy += tmp_energy;
			}
		} else {
			Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
		}
	}

	// calculates the current energy of this component
	float AmberNonBonded::updateEnergy()
	{
		// Calculate squared cut_off values
		float	cut_off_electrostatic_2 = cut_off_electrostatic_ * cut_off_electrostatic_;
		float	cut_off_vdw_2 = cut_off_vdw_ * cut_off_vdw_;


		// Define the different components of the non-bonded energy
		float vdw_energy = 0;
		float vdw_energy_1_4 = 0;
		float electrostatic_energy = 0;
		float electrostatic_energy_1_4 = 0;
		float distance_2;
		float inverse_distance_2;
		float inverse_distance_6;

		vector<FFPSLennardJones::LennardJones>::iterator it = non_bonded_.begin();			

		if (force_field_->periodic_boundary.isEnabled()) 
		{   
			// Periodic boundary is enabled

			// calculate the box period (half of the box period)
			Box3 box = force_field_->periodic_boundary.getBox();
			float period_x = box.b.x - box.a.x;
			float period_y = box.b.y - box.a.y;
			float period_z = box.b.z - box.a.z;
			float half_period_x = period_x * 0.5;
			float half_period_y = period_y * 0.5;
			float half_period_z = period_z * 0.5;

			Vector3 difference;

			// Calculate 1-4 interactions

			for (Size i = 0; i < number_of_1_4_ ; i++, it++) 
			{
				difference = (*it).atom1->getPosition() - (*it).atom2->getPosition();

				// Search minimal image

				if (difference.x < -half_period_x) difference.x += period_x;
				else if (difference.x > half_period_x) difference.x -= period_x;

				if (difference.y < -half_period_y) difference.y += period_y;
				else if (difference.y > half_period_y) difference.y -= period_y;

				if (difference.z < -half_period_z) difference.z += period_z;
				else if (difference.z > half_period_z) difference.z -= period_z;

				distance_2 = difference.getSquareLength();
	
				if ( distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) 
				{
 						inverse_distance_2 = 1/distance_2;
						electrostatic_energy_1_4 += ((*it).atom1->getCharge() * (*it).atom2->getCharge()) * sqrt(inverse_distance_2);

						if (distance_2 <= cut_off_vdw_2) 
						{
							inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
							float tmp_energy = inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B); 
							//cout << "DATA:  d = " << sqrt(distance_2) << "   A = " << it->values.A << "   B = " << it->values.B << endl;
							//cout << "VdW1-4(" << it->atom1->getName() << "-" << it->atom2->getName() << "): " << tmp_energy << endl;
							vdw_energy_1_4 += tmp_energy;
						}
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

			// Calculate non 1-4 nonbonded interactions

			for ( ; it != non_bonded_.end() ; it++) 
			{
				difference = (*it).atom1->getPosition() - (*it).atom2->getPosition();

				// Search minimal image

				if (difference.x < -half_period_x) difference.x += period_x;
				else if (difference.x > half_period_x) difference.x -= period_x;

				if (difference.y < -half_period_y) difference.y += period_y;
				else if (difference.y > half_period_y) difference.y -= period_y;

				if (difference.z < -half_period_z) difference.z += period_z;
				else if (difference.z > half_period_z) difference.z -= period_z;

				distance_2 = difference.getSquareLength();
	
				if ((distance_2 > 0) && (distance_2 <= cut_off_electrostatic_2))
				{ 
					inverse_distance_2 = 1/distance_2;
					electrostatic_energy += ((*it).atom1->getCharge() * (*it).atom2->getCharge()) * sqrt(inverse_distance_2);

					if (distance_2 <= cut_off_vdw_2)		
					{
						inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
						float tmp_energy = inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B); 
						//cout << "DATA:  d = " << sqrt(distance_2) << "   A = " << it->values.A << "   B = " << it->values.B << endl;
						//cout << "VdW(" << it->atom1->getName() << "-" << it->atom2->getName() << "): " << tmp_energy << endl;
						vdw_energy += tmp_energy;
					}
				} else { 
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}
	
		} else {  
			// Periodic Boundary not enabled

			// Calculate 1-4 interactions
	
			for (int i = 0; i < number_of_1_4_ ; i++, it++) 
			{
				distance_2 = ((*it).atom1->getPosition()).getSquareDistance((*it).atom2->getPosition());
	
				if ( distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) 
				{ 
					inverse_distance_2 = 1/distance_2;
					electrostatic_energy_1_4 += ((*it).atom1->getCharge() * (*it).atom2->getCharge()) * sqrt(inverse_distance_2);

					if ( distance_2 <= cut_off_vdw_2) 
					{
						inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
						float tmp_energy = inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B); 
						//cout << "DATA:  d = " << sqrt(distance_2) << "   A = " << it->values.A << "   B = " << it->values.B << endl;
						//cout << "VdW1-4(" << it->atom1->getName() << "-" << it->atom2->getName() << "): " << tmp_energy << endl;
						vdw_energy_1_4 += tmp_energy;
					}
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

			// Calculate the non 1-4 nonbonded interactions

			for ( ; it != non_bonded_.end(); it++) 
			{
				distance_2 = ((*it).atom1->getPosition()).getSquareDistance((*it).atom2->getPosition());

				if ( distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) 
				{ 
					inverse_distance_2 = 1/distance_2;
					electrostatic_energy += ((*it).atom1->getCharge() * (*it).atom2->getCharge()) * sqrt(inverse_distance_2);

					if (distance_2 <= cut_off_vdw_2) 
					{
						inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
						float tmp_energy = inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B); 
						//cout << "DATA:  d = " << sqrt(distance_2) << "   A = " << it->values.A << "   B = " << it->values.B << endl;
						//cout << "VdW(" << it->atom1->getName() << "-" << it->atom2->getName() << "): " << tmp_energy << endl;
						vdw_energy += tmp_energy;
					}
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}
		}

		// 
		float vdw_factor = 1.0;
		float vdw_factor_1_4 = scaling_vdw_1_4_ * vdw_factor;

		using namespace Constants;
		float electrostatic_factor = NA * e0 * e0 / (4 * PI * VACUUM_PERMITTIVITY * 1000 * 1e-10);
		float electrostatic_factor_1_4 = scaling_electrostatic_1_4_ * electrostatic_factor;

		vdw_energy_ = vdw_factor * vdw_energy + vdw_factor_1_4 * vdw_energy_1_4;
		electrostatic_energy_ = electrostatic_factor * electrostatic_energy + electrostatic_factor_1_4 * electrostatic_energy_1_4;
		energy_ =  vdw_energy_ + electrostatic_energy_;

		return energy_;
	}



	// calculates the current vdw energy 
	float AmberNonBonded::updateVdWEnergy()
	{
		// Define the squared cut_off and the energy components
		float	cut_off_vdw_2 = cut_off_vdw_ * cut_off_vdw_;
		float vdw_energy = 0;
		float vdw_energy_1_4 = 0;
		float distance_2;
		float	inverse_distance_2;
		float inverse_distance_6;

		vector<FFPSLennardJones::LennardJones>::iterator it = non_bonded_.begin();			

		if (force_field_->periodic_boundary.isEnabled()) 
		{ 
			// Periodic boundary is enabled

			// calculate the box period (half of the box period)
			Box3 box = force_field_->periodic_boundary.getBox();
			float period_x = box.b.x - box.a.x;
			float period_y = box.b.y - box.a.y;
			float period_z = box.b.z - box.a.z;
			float half_period_x = period_x * 0.5;
			float half_period_y = period_y * 0.5;
			float half_period_z = period_z * 0.5;

			Vector3 difference;

			// Calculate 1-4 interactions

			for (Size i = 0; i < number_of_1_4_ ; i++, it++) 
			{
				difference = (*it).atom1->getPosition() - (*it).atom2->getPosition();

				// Search minimal image

				if (difference.x < -half_period_x) difference.x += period_x;
				else if (difference.x > half_period_x) difference.x -= period_x;

				if (difference.y < -half_period_y) difference.y += period_y;
				else if (difference.y > half_period_y) difference.y -= period_y;

				if (difference.z < -half_period_z) difference.z += period_z;
				else if (difference.z > half_period_z) difference.z -= period_z;

				distance_2 = difference.getSquareLength();
	
				if ( distance_2 > 0 && distance_2 <= cut_off_vdw_2) {
							inverse_distance_2 = 1 / distance_2;
							inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
							vdw_energy_1_4 += inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B);
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

			// Calculate non 1-4 nonbonded interactions

			for ( ; it != non_bonded_.end() ; it++) {
				difference = (*it).atom1->getPosition() - (*it).atom2->getPosition();

				// Search minimal image

				if (difference.x < -half_period_x) difference.x += period_x;
				else if (difference.x > half_period_x) difference.x -= period_x;

				if (difference.y < -half_period_y) difference.y += period_y;
				else if (difference.y > half_period_y) difference.y -= period_y;

				if (difference.z < -half_period_z) difference.z += period_z;
				else if (difference.z > half_period_z) difference.z -= period_z;

				distance_2 = difference.getSquareLength();
	
				if ( distance_2 > 0 && distance_2 <= cut_off_vdw_2) {
							inverse_distance_2 = 1 / distance_2;
							inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
							vdw_energy += inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B);
				} else { 
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

	
		} else {  // Periodic boundary not enabled

			// Calculate 1-4 interactions
	
			for (int i = 0; i < number_of_1_4_ ; i++, it++) 
			{
				distance_2 = ((*it).atom1->getPosition()).getSquareDistance((*it).atom2->getPosition());
	
				if (distance_2 > 0 && distance_2 <= cut_off_vdw_2) 
				{
					inverse_distance_2 = 1 / distance_2;
					inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
					vdw_energy_1_4 += inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B);
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

			// Calculate the non 1-4 nonbonded interactions

			for ( ; it != non_bonded_.end(); it++) {
				distance_2 = ((*it).atom1->getPosition()).getSquareDistance((*it).atom2->getPosition());

				if ( distance_2 > 0 && distance_2 <= cut_off_vdw_2) {
							inverse_distance_2 = 1 / distance_2;
							inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
							vdw_energy += inverse_distance_6 * (it->values.A * inverse_distance_6 - it->values.B);
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}
		}

		// BAUSTELLE: Einheiten?
		float vdw_factor = 1.0;
		float vdw_factor_1_4 = scaling_vdw_1_4_ * vdw_factor;

		vdw_energy_ = vdw_factor * vdw_energy + vdw_factor_1_4 * vdw_energy_1_4;

		return (vdw_energy_);
	}




	// calculates the current electrostatic energy 
	float AmberNonBonded::updateElectrostaticEnergy()
	{
		// Define the squared cut_off and the energy components
		float	cut_off_electrostatic_2 = cut_off_electrostatic_ * cut_off_electrostatic_;
		float electrostatic_energy = 0;
		float electrostatic_energy_1_4 = 0;
		float	distance_2;

		vector<FFPSLennardJones::LennardJones>::iterator it = non_bonded_.begin();			

		if (force_field_->periodic_boundary.isEnabled()) {   // Periodic boundary is enabled

			// calculate the box period (half of the box period)
			Box3 box = force_field_->periodic_boundary.getBox();
			float period_x = box.b.x - box.a.x;
			float period_y = box.b.y - box.a.y;
			float period_z = box.b.z - box.a.z;
			float half_period_x = period_x * 0.5;
			float half_period_y = period_y * 0.5;
			float half_period_z = period_z * 0.5;

			Vector3 difference;

			// Calculate 1-4 interactions

			for (Size i = 0; i < number_of_1_4_ ; i++, it++) {
				difference = (*it).atom1->getPosition() - (*it).atom2->getPosition();

				// Search minimal image

				if (difference.x < -half_period_x) difference.x += period_x;
				else if (difference.x > half_period_x) difference.x -= period_x;

				if (difference.y < -half_period_y) difference.y += period_y;
				else if (difference.y > half_period_y) difference.y -= period_y;

				if (difference.z < -half_period_z) difference.z += period_z;
				else if (difference.z > half_period_z) difference.z -= period_z;

				distance_2 = difference.getSquareLength();
	
				if (distance_2 > 0) {
					if ( distance_2 <= cut_off_electrostatic_2) { 
						electrostatic_energy_1_4 += ((*it).atom1->getCharge() * (*it).atom2->getCharge())/ sqrt(distance_2);
					}
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

			// Calculate non 1-4 nonbonded interactions

			for ( ; it != non_bonded_.end() ; it++) {
				difference = (*it).atom1->getPosition() - (*it).atom2->getPosition();

				// Search minimal image

				if (difference.x < -half_period_x) difference.x += period_x;
				else if (difference.x > half_period_x) difference.x -= period_x;

				if (difference.y < -half_period_y) difference.y += period_y;
				else if (difference.y > half_period_y) difference.y -= period_y;

				if (difference.z < -half_period_z) difference.z += period_z;
				else if (difference.z > half_period_z) difference.z -= period_z;

				distance_2 = difference.getSquareLength();
	
				if (distance_2 > 0 ) 
				{
					if ( distance_2 <= cut_off_electrostatic_2) { 
						electrostatic_energy += ((*it).atom1->getCharge() * (*it).atom2->getCharge())/ sqrt(distance_2);
					}

				} else { 
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

	
		} else {

			// Calculate 1-4 interactions
	
			for (int i = 0; i < number_of_1_4_ ; i++, it++) {
				distance_2 = ((*it).atom1->getPosition()).getSquareDistance((*it).atom2->getPosition());
	
				if ( distance_2 > 0) {
					if ( distance_2 <= cut_off_electrostatic_2) { 
						electrostatic_energy_1_4 += ((*it).atom1->getCharge() * (*it).atom2->getCharge())/ sqrt(distance_2);
					}
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}

			// Calculate the non 1-4 nonbonded interactions

			for ( ; it != non_bonded_.end(); it++) {
				distance_2 = ((*it).atom1->getPosition()).getSquareDistance((*it).atom2->getPosition());

				if ( distance_2 > 2) {
					if ( distance_2 <= cut_off_electrostatic_2) { 
						electrostatic_energy += ((*it).atom1->getCharge() * (*it).atom2->getCharge())/ sqrt(distance_2);
					}
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			}
		}

		// BAUSTELLE: Einheiten?
		using namespace Constants;
		float electrostatic_factor = NA * e0 * e0 / (4 * PI * VACUUM_PERMITTIVITY * 1000 * 1e-10);
		float electrostatic_factor_1_4 = scaling_electrostatic_1_4_ * electrostatic_factor;

    electrostatic_energy_ = electrostatic_factor * electrostatic_energy + electrostatic_factor_1_4 * electrostatic_energy_1_4;

		return (electrostatic_energy_);
	}


	// calculates the current forces of this component
	void AmberNonBonded::updateForces()
	{

		// Define variables for the squared cut_offs, the unit factors and so on
		float	cut_off_electrostatic_2 = cut_off_electrostatic_ *cut_off_electrostatic_;
		float	cut_off_vdw_2 = cut_off_vdw_ * cut_off_vdw_;
		float	factor;
		float	e_scaling_factor = 1/(4 * Constants::PI * Constants::VACUUM_PERMITTIVITY); 
		float e_scaling_factor_1_4 = e_scaling_factor * scaling_electrostatic_1_4_;
		const float vdw_scaling_factor = 1.0;
		float vdw_scaling_factor_1_4 = vdw_scaling_factor * scaling_vdw_1_4_;
		float distance_2;
		float inverse_distance;
		float inverse_distance_2;
		float inverse_distance_6;
		Vector3	direction;
		Vector3 position;

		// BAUSTELLE: hier fehlen die richtigen Parameter : 1/4 PI epsilon epsilon_0
		// BAUSTELLE: Distanzabhaengige Dielektrizitaetskonstante

		vector<FFPSLennardJones::LennardJones>::iterator it = non_bonded_.begin();			

		if (force_field_->periodic_boundary.isEnabled()) {   // periodic boundary is enabled

			// Calculate periods and half periods
			Box3 box = force_field_->periodic_boundary.getBox();
			float period_x = box.b.x - box.a.x; 
			float period_y = box.b.y - box.a.y; 
			float period_z = box.b.z - box.a.z; 
			float half_period_x = period_x * 0.5;
			float half_period_y = period_y * 0.5;
			float half_period_z = period_z * 0.5;

			// 1-4 interactions

			for (Size i = 0 ; i < number_of_1_4_; i++, it++) {
				position = (*it).atom1->getPosition();
				direction = position - (*it).atom2->getPosition();

				// Search for the minimal image: the direction with minimal length

				if (direction.x < -half_period_x)     direction.x += period_x;
				else if (direction.x > half_period_x) direction.x -= period_x;

				if (direction.y < -half_period_y)     direction.y += period_y;
				else if (direction.y > half_period_y) direction.y -= period_y;

				if (direction.z < -half_period_z)     direction.z += period_z;
				else if (direction.z > half_period_z) direction.z -= period_z;

				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) 
				{ 
					inverse_distance_2 = 1/distance_2;
					inverse_distance = sqrt(inverse_distance_2);
					factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * e_scaling_factor_1_4;

					if ( distance_2 <= cut_off_vdw_2) 
					{
						inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
						factor -= inverse_distance_6 * vdw_scaling_factor_1_4 * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
					}
					factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}

			// non 1-4 interactions

			for ( ; it != non_bonded_.end(); it++) {
				position = (*it).atom1->getPosition();
				direction = position - (*it).atom2->getPosition();

				// Search for the minimal image: the direction with minimal length

				if (direction.x < -half_period_x)     direction.x += period_x;
				else if (direction.x > half_period_x) direction.x -= period_x;

				if (direction.y < -half_period_y)     direction.y += period_y;
				else if (direction.y > half_period_y) direction.y -= period_y;

				if (direction.z < -half_period_z)     direction.z += period_z;
				else if (direction.z > half_period_z) direction.z -= period_z;

				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 &&  distance_2 <= cut_off_electrostatic_2) { 
						inverse_distance_2 = 1/distance_2;
						inverse_distance = sqrt(inverse_distance_2);
						factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * e_scaling_factor;

						if ( distance_2 <= cut_off_vdw_2) {
							inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
							factor -= inverse_distance_6 * vdw_scaling_factor * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
						}
						factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}
		} else {    // periodic boundary is not enabled

			for (int i = 0 ; i < number_of_1_4_; i++, it++) 
			{
				direction = (*it).atom1->getPosition() - (*it).atom2->getPosition();
				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) { 
						inverse_distance_2 = 1/distance_2;
						inverse_distance = sqrt(inverse_distance_2);
						factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * e_scaling_factor_1_4;

						if ( distance_2 <= cut_off_vdw_2) {
							inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
							factor -= inverse_distance_6 * vdw_scaling_factor_1_4 * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
						}
						factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}

			for ( ; it != non_bonded_.end(); it++) {
				direction = (*it).atom1->getPosition() - (*it).atom2->getPosition();
				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) { 
						inverse_distance_2 = 1/distance_2;
						inverse_distance = sqrt(inverse_distance_2);
						factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * e_scaling_factor;

						if ( distance_2 <= cut_off_vdw_2) {
							inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
							factor -= inverse_distance_6 * vdw_scaling_factor * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
						}
						factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}
		}
	}


	// calculates the current vdw forces
	void AmberNonBonded::updateVdWForces() const
	{
		float	cut_off_vdw_2 = cut_off_vdw_ * cut_off_vdw_;
		float	factor;
		const float vdw_scaling_factor = 1.0;
		float vdw_scaling_factor_1_4 = vdw_scaling_factor * scaling_vdw_1_4_;
		Vector3	direction;
		Vector3 position;
		float distance_2;
		float inverse_distance_2;
		float inverse_distance_6;

		// BAUSTELLE: hier fehlen die richtigen Parameter : 1/4 PI epsilon epsilon_0
		// BAUSTELLE: Distanzabhaengige Dielektrizitaetskonstante

		vector<FFPSLennardJones::LennardJones>::const_iterator it = non_bonded_.begin();			

		if (force_field_->periodic_boundary.isEnabled()) {   // periodic boundary is enabled

			// Calculate periods and half periods
			Box3 box = force_field_->periodic_boundary.getBox();
			float period_x = box.b.x - box.a.x; 
			float period_y = box.b.y - box.a.y; 
			float period_z = box.b.z - box.a.z; 
			float half_period_x = period_x * 0.5;
			float half_period_y = period_y * 0.5;
			float half_period_z = period_z * 0.5;

			// 1-4 interactions

			for (Size i = 0 ; i < number_of_1_4_; i++, it++) {
				position = (*it).atom1->getPosition();
				direction = position - (*it).atom2->getPosition();

				// Search for the minimal image: the direction with minimal length

				if (direction.x < -half_period_x)     direction.x += period_x;
				else if (direction.x > half_period_x) direction.x -= period_x;

				if (direction.y < -half_period_y)     direction.y += period_y;
				else if (direction.y > half_period_y) direction.y -= period_y;

				if (direction.z < -half_period_z)     direction.z += period_z;
				else if (direction.z > half_period_z) direction.z -= period_z;

				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 && distance_2 <= cut_off_vdw_2) {
						inverse_distance_2 = 1/distance_2;
						inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
						factor = inverse_distance_6 * vdw_scaling_factor_1_4 * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
						factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() - direction);
				(*it).atom2->setForce((*it).atom2->getForce() + direction);
			
			}

			// non 1-4 interactions

			for ( ; it != non_bonded_.end(); it++) {
				position = (*it).atom1->getPosition();
				direction = position - (*it).atom2->getPosition();

				// Search for the minimal image: the direction with minimal length

				if (direction.x < -half_period_x)     direction.x += period_x;
				else if (direction.x > half_period_x) direction.x -= period_x;

				if (direction.y < -half_period_y)     direction.y += period_y;
				else if (direction.y > half_period_y) direction.y -= period_y;

				if (direction.z < -half_period_z)     direction.z += period_z;
				else if (direction.z > half_period_z) direction.z -= period_z;

				distance_2 = direction.getSquareLength();

				if (distance_2 > 0 && distance_2 <= cut_off_vdw_2) {
					inverse_distance_2 = 1/distance_2;
					inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
					factor = inverse_distance_6 * vdw_scaling_factor * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
					factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() - direction);
				(*it).atom2->setForce((*it).atom2->getForce() + direction);
			
			}
		} else {    // periodic boundary is not enabled

			// 1-4 interactions

			for (int i = 0 ; i < number_of_1_4_; i++, it++) {
				direction = (*it).atom1->getPosition() - (*it).atom2->getPosition();
				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 && distance_2 <= cut_off_vdw_2) {
						inverse_distance_2 = 1/distance_2;
						inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
						factor = inverse_distance_6 * vdw_scaling_factor_1_4 * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
						factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() - direction);
				(*it).atom2->setForce((*it).atom2->getForce() + direction);
			
			}

			// non 1-4 interactions

			for ( ; it != non_bonded_.end(); it++) {
				direction = (*it).atom1->getPosition() - (*it).atom2->getPosition();
				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 && distance_2 <= cut_off_vdw_2) {
						inverse_distance_2 = 1/distance_2;
						inverse_distance_6 = inverse_distance_2 * inverse_distance_2 * inverse_distance_2;
						factor = inverse_distance_6 * vdw_scaling_factor * (12 * (*it).values.A * inverse_distance_6 - 6 * (*it).values.B);
						factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() - direction);
				(*it).atom2->setForce((*it).atom2->getForce() + direction);
			
			}
		}
	}


	// calculates the current electrostatic forces 
	void AmberNonBonded::updateElectrostaticForces() const
	{
		float	cut_off_electrostatic_2 = cut_off_electrostatic_ *cut_off_electrostatic_;
		float	factor;
		float	unit_factor = 1/ (4 * Constants::PI * Constants::VACUUM_PERMITTIVITY); 
		float unit_factor_1_4 = unit_factor * scaling_electrostatic_1_4_;
		float distance_2;
		float inverse_distance;
		float inverse_distance_2;
		Vector3	direction;
		Vector3 position;

		// BAUSTELLE: hier fehlen die richtigen Parameter : 1/4 PI epsilon epsilon_0
		// BAUSTELLE: Distanzabhaengige Dielektrizitaetskonstante

		vector<FFPSLennardJones::LennardJones>::const_iterator it = non_bonded_.begin();			

		if (force_field_->periodic_boundary.isEnabled()) {   // periodic boundary is enabled

			// Calculate periods and half periods
			Box3 box = force_field_->periodic_boundary.getBox();
			float period_x = box.b.x - box.a.x; 
			float period_y = box.b.y - box.a.y; 
			float period_z = box.b.z - box.a.z; 
			float half_period_x = period_x * 0.5;
			float half_period_y = period_y * 0.5;
			float half_period_z = period_z * 0.5;

			// 1-4 interactions

			for (Size i = 0 ; i < number_of_1_4_; i++, it++) {
				position = (*it).atom1->getPosition();
				direction = position - (*it).atom2->getPosition();

				// Search for the minimal image: the direction with minimal length

				if (direction.x < -half_period_x)     direction.x += period_x;
				else if (direction.x > half_period_x) direction.x -= period_x;

				if (direction.y < -half_period_y)     direction.y += period_y;
				else if (direction.y > half_period_y) direction.y -= period_y;

				if (direction.z < -half_period_z)     direction.z += period_z;
				else if (direction.z > half_period_z) direction.z -= period_z;

				distance_2 = direction.getSquareLength();

				if (distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) { 
					inverse_distance_2 = 1/distance_2;
					inverse_distance = sqrt(inverse_distance_2);
					factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * unit_factor_1_4;
					factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}

			// non 1-4 interactions

			for ( ; it != non_bonded_.end(); it++) {
				position = (*it).atom1->getPosition();
				direction = position - (*it).atom2->getPosition();

				// Search for the minimal image: the direction with minimal length

				if (direction.x < -half_period_x)     direction.x += period_x;
				else if (direction.x > half_period_x) direction.x -= period_x;

				if (direction.y < -half_period_y)     direction.y += period_y;
				else if (direction.y > half_period_y) direction.y -= period_y;

				if (direction.z < -half_period_z)     direction.z += period_z;
				else if (direction.z > half_period_z) direction.z -= period_z;

				distance_2 = direction.getSquareLength();

				if (distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) { 
					inverse_distance_2 = 1/distance_2;
					inverse_distance = sqrt(inverse_distance_2);
					factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * unit_factor;
					factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}
		} else {    // periodic boundary is not enabled

			// 1-4 interactions

			for (int i = 0 ; i < number_of_1_4_; i++, it++) 
			{
				direction = (*it).atom1->getPosition() - (*it).atom2->getPosition();
				distance_2 = direction.getSquareLength();

				if (distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) { 
					inverse_distance_2 = 1/distance_2;
					inverse_distance = sqrt(inverse_distance_2);
					factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * unit_factor_1_4;
					factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}

			// non 1-4 interactions

			for ( ; it != non_bonded_.end(); it++) {
				direction = (*it).atom1->getPosition() - (*it).atom2->getPosition();
				distance_2 = direction.getSquareLength();

				if ( distance_2 > 0 && distance_2 <= cut_off_electrostatic_2) { 
					inverse_distance_2 = 1/distance_2;
					inverse_distance = sqrt(inverse_distance_2);
					factor = (*it).atom1->getCharge() * (*it).atom2->getCharge() * inverse_distance * unit_factor;
					factor *= inverse_distance_2;
				} else {
					Log.level(LogStream::WARNING) << "distance between atoms too small" << endl;
				}
			
				direction = factor * direction;
				(*it).atom1->setForce((*it).atom1->getForce() + direction);
				(*it).atom2->setForce((*it).atom2->getForce() - direction);
			
			}
		}
	}

	float AmberNonBonded::getElectrostaticEnergy() const
	{
		return electrostatic_energy_;
	}

	float AmberNonBonded::getVdwEnergy() const
	{
		return vdw_energy_;
	}

} // namespace Ball
@
