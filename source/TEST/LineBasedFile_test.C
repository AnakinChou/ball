// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// $Id: LineBasedFile_test.C,v 1.13.2.2 2003/02/05 15:34:03 anker Exp $

#include <BALL/CONCEPT/classTest.h>

///////////////////////////
#include <BALL/FORMAT/lineBasedFile.h>
///////////////////////////

START_TEST(LineBasedFile, "$Id: LineBasedFile_test.C,v 1.13.2.2 2003/02/05 15:34:03 anker Exp $")

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////

using namespace BALL;


LineBasedFile* fl;

CHECK(LineBasedFile() throw())
	fl = new LineBasedFile;
	TEST_NOT_EQUAL(fl, 0)
RESULT

CHECK(~LineBasedFile() throw())
	delete fl;
RESULT

CHECK(BALL_CREATE(LineBasedFile))
	LineBasedFile c;
	LineBasedFile* ptr = (LineBasedFile*)c.create(false, true);
	TEST_NOT_EQUAL(ptr, 0)
RESULT

CHECK(LineBasedFile(const String& filename, File::OpenMode open_mode = std::ios::in)
			throw(Exception::FileNotFound))
	LineBasedFile f1("data/LineBasedFile_test.txt");
	TEST_EQUAL(f1.getLineNumber(), 0)
	TEST_EQUAL(f1.getLine(), "")
	f1.readLine();
	TEST_EQUAL(f1.getLineNumber(), 1)
	TEST_EQUAL(f1.getLine(), "line1")
	f1.close();

	LineBasedFile* f2 = 0;
	TEST_EXCEPTION(Exception::FileNotFound, f2 = new LineBasedFile("XXXXXXXX.txt"))
	if (f2 != 0)
	{
		delete f2;
	}
RESULT

LineBasedFile fx;

CHECK(LineBasedFile(const LineBasedFile& f) throw())
	LineBasedFile f1("data/LineBasedFile_test.txt");
	TEST_EQUAL(f1.readLine(), true)
	TEST_EQUAL(f1.getLine(), "line1")
	f1.close();

	LineBasedFile f2(f1);
	TEST_EQUAL(f2.getLineNumber(), 1)
	TEST_EQUAL(f2.getLine(), "line1")
	TEST_EQUAL(f2.readLine(), true)
	TEST_EQUAL(f2.getLine(), "/0/ /1/ /2 2//3/")

	LineBasedFile f3;
	LineBasedFile f4(f3);
RESULT

CHECK(LineBasedFile& operator = (const LineBasedFile& file) throw())
	LineBasedFile f1("data/LineBasedFile_test.txt");
	f1.readLine();
	TEST_EQUAL(f1.getLine(), "line1")

	LineBasedFile f2;
	f2 = f1;
	TEST_EQUAL(f2.getLineNumber(), 1)
	TEST_EQUAL(f2.getLine(), "line1")
RESULT

CHECK(clear() throw())
	LineBasedFile f1("data/LineBasedFile_test.txt");
	f1.readLine();
	f1.clear();
	TEST_EQUAL(f1.getLineNumber(), 0)
	TEST_EQUAL(f1.getLine(), "")

	fx.clear();
RESULT

CHECK(getLineNumber() const  throw())
	LineBasedFile f1("data/LineBasedFile_test.txt");
	TEST_EQUAL(f1.getLineNumber(), 0)
	f1.readLine();
	TEST_EQUAL(f1.getLineNumber(), 1)

	TEST_EQUAL(fx.getLineNumber(), 0)
RESULT

LineBasedFile f1("data/LineBasedFile_test.txt");

CHECK(getLine() const  throw())
	TEST_EQUAL(f1.getLine(), "")
	f1.readLine();
	TEST_EQUAL(f1.getLine(), "line1")

	TEST_EQUAL(fx.getLine(), "")
RESULT

CHECK(getLine() throw())
	TEST_EQUAL(f1.getLine(), "line1")
	f1.getLine() = "test";
	TEST_EQUAL(f1.getLine(), "test")
	f1.getLine() = "line1";
	TEST_EQUAL(f1.getLine(), "line1")
RESULT

CHECK(getField(Position pos = 0, const String& quotes = "", 
			const String& delimiters = String::CHARACTER_CLASS__WHITESPACE) 
			const  throw(Exception::IndexUnderflow))

	TEST_EQUAL(f1.getField(), "line1")
	TEST_EQUAL(f1.getField(1), "")
	TEST_EXCEPTION(Exception::IndexUnderflow, f1.getField(-99))
	f1.readLine();
	TEST_EQUAL(f1.getField(), "/0/")
	TEST_EQUAL(f1.getField(1), "/1/")
	TEST_EQUAL(f1.getField(2), "/2")
	TEST_EQUAL(f1.getField(0, "/"), "0")
	TEST_EQUAL(f1.getField(1, "/"), "1")
	TEST_EQUAL(f1.getField(2, "/"), "2 23")
	TEST_EQUAL(f1.getField(3, "/"), "")

	TEST_EQUAL(fx.getField(), "")
RESULT

CHECK(startsWith(const String& text) const  throw())
	TEST_EQUAL(f1.startsWith("/0/"), true)
	TEST_EQUAL(f1.startsWith("/0/ /1/ /2 2//3/"), true)
	TEST_EQUAL(f1.startsWith("/0/ /1/ /2 2//3/X"), false)

	TEST_EQUAL(fx.startsWith(""), true)
RESULT

CHECK(has(const String& text) const  throw())
	TEST_EQUAL(f1.has("/0/"), true)
	TEST_EQUAL(f1.has("/"), true)
	TEST_EQUAL(f1.has("/1/"), true)
	TEST_EQUAL(f1.has("/3/"), true)
	TEST_EQUAL(f1.has("X"), false)

	TEST_EQUAL(fx.has("X"), false)
	TEST_EQUAL(fx.has(""), true)
RESULT

CHECK(search(const String& text, bool return_to_point) throw())
	TEST_EQUAL(f1.search("line3"), true)
	TEST_EQUAL(f1.search("line4-"), true)
	TEST_EQUAL(f1.search("line4-"), false)
	TEST_EQUAL(f1.getLine(), "line7-")
  f1.rewind();

	f1.skipLines(2);
	TEST_EQUAL(f1.getLine(), "line3-")
	TEST_EQUAL(f1.search("XXX", true), false)
	TEST_EQUAL(f1.getLine(), "line3-")

  f1.rewind();
	TEST_EQUAL(f1.search("#"), true)
	TEST_EQUAL(f1.getLine(), "###########")

	TEST_EXCEPTION(Exception::ParseError, fx.search("line4-"))
RESULT

CHECK(search(const String& text, const String& stop, bool return_to_point) throw())
  f1.rewind();
	TEST_EQUAL(f1.search("line3", "line4", true), true)
	TEST_EQUAL(f1.getLine(), "line3-")
	TEST_EQUAL(f1.getLineNumber(), 3)

  f1.rewind();
	TEST_EQUAL(f1.search("line4", "line3", false), false)
	TEST_EQUAL(f1.getLine(), "line3-")
	TEST_EQUAL(f1.getLineNumber(), 3)

  f1.rewind();
	TEST_EQUAL(f1.search("/", "l", false), false)
	TEST_EQUAL(f1.getLine(), "line1")
	TEST_EQUAL(f1.getLineNumber(), 1)

  f1.rewind();
	f1.readLine();
	f1.readLine();
	TEST_EQUAL(f1.getLine(), "/0/ /1/ /2 2//3/")
	bool  erg = f1.search("line4", "line3", true);
	TEST_EQUAL(erg, false)
	TEST_EQUAL(f1.getLine(), "/0/ /1/ /2 2//3/")
	TEST_EQUAL(f1.getLineNumber(), 2)

  f1.rewind();
	f1.skipLines(2);
	TEST_EQUAL(f1.getLine(), "line3-")
	TEST_EQUAL(f1.search("XXX", "ZZZZZ", true), false)
	TEST_EQUAL(f1.getLine(), "line3-")

  f1.rewind();
	erg = f1.search("#", "l", false);
	TEST_EQUAL(erg, false)
	TEST_EQUAL(f1.getLine(), "line1")

  f1.rewind();
	erg = f1.search("#", "l", true);
	TEST_EQUAL(erg, false)
	TEST_EQUAL(f1.getLineNumber(), 0)

  f1.rewind();
	erg = f1.search("line7", "#", false);
	TEST_EQUAL(erg, false)
	TEST_EQUAL(f1.getLine(), "###########")


	TEST_EXCEPTION(Exception::ParseError, fx.search("line4", "line3"))
RESULT

CHECK(switchString(const std::vector<String>& data) const  throw())
  f1.rewind();
	f1.readLine();

	vector<String> vec;
	vec.push_back("line");
	vec.push_back("line1");
	vec.push_back("line2");
	vec.push_back("");

	TEST_EQUAL(f1.switchString(vec), 1)
	f1.readLine();
	TEST_EQUAL(f1.switchString(vec), -1)

	TEST_EQUAL(fx.switchString(vec), 3)
RESULT

CHECK(test(const char* file, int line, bool condition, const String& msg)
			const  throw(LineBasedFileError))
	f1.test(__FILE__, __LINE__, true, "test");
	TEST_EXCEPTION(Exception::ParseError, f1.test(__FILE__, __LINE__, false, "test") )
	fx.test(__FILE__, __LINE__, true, "test");
RESULT

CHECK(readLine() throw(LineBasedFileError))
  f1.rewind();
	f1.readLine();

	TEST_EQUAL(f1.getLine(), "line1")

	TEST_EXCEPTION(Exception::ParseError, fx.readLine())
	TEST_EQUAL(fx.getLine(), "")
RESULT

CHECK(skipLines(Size number = 1) throw(Exception::IndexUnderflow, LineBasedFileError))
  f1.rewind();
	TEST_EQUAL(f1.skipLines(2), true)
	TEST_EQUAL(f1.getLine(), "line3-")
	TEST_EQUAL(f1.getLineNumber(), 3)
	TEST_EQUAL(f1.skipLines(5), false)

	TEST_EXCEPTION(Exception::ParseError, fx.skipLines(2))
	TEST_EQUAL(fx.getLine(), "")
	TEST_EQUAL(fx.getLineNumber(), 0)
RESULT

CHECK(rewind() throw(LineBasedFileError))
  f1.rewind();
	TEST_EQUAL(f1.getLine(), "")
	TEST_EQUAL(f1.getLineNumber(), 0)

  TEST_EXCEPTION(Exception::ParseError,fx.rewind())
	TEST_EQUAL(fx.getLine(), "")
	TEST_EQUAL(fx.getLineNumber(), 0)
RESULT

CHECK(gotoLine(Position line_number) throw(LineBasedFileError))
  f1.rewind();
	f1.skipLines(4);
	TEST_EQUAL(f1.gotoLine(3), true)
	TEST_EQUAL(f1.getLine(), "line3-" )
	TEST_EQUAL(f1.getLineNumber(), 3)

	TEST_EQUAL(f1.gotoLine(5), true)
	TEST_EQUAL(f1.getLine(), "line5-" )
	TEST_EQUAL(f1.getLineNumber(), 5)

	TEST_EQUAL(f1.gotoLine(8), false)
	TEST_EQUAL(f1.getLine(), "line7-" )
	TEST_EQUAL(f1.getLineNumber(), 7)

  TEST_EXCEPTION(Exception::ParseError,fx.gotoLine(2))
	TEST_EQUAL(fx.getLine(), "")
	TEST_EQUAL(fx.getLineNumber(), 0)
RESULT


/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
END_TEST
