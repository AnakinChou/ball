// $Id: PropertyManager_test.C,v 1.19.4.1 2002/05/15 23:39:57 oliver Exp $
#include <BALL/CONCEPT/classTest.h>

///////////////////////////
#include <BALL/CONCEPT/property.h>
#include <BALL/CONCEPT/persistenceManager.h>
#include <BALL/CONCEPT/textPersistenceManager.h>
#include <BALL/KERNEL/protein.h>
#include <fstream>

///////////////////////////

START_TEST(PropertyManager, "$Id: PropertyManager_test.C,v 1.19.4.1 2002/05/15 23:39:57 oliver Exp $")

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////

using namespace BALL;
using namespace std;

NamedProperty* np;

CHECK(NamedProperty::NamedProperty())
	np = new NamedProperty();
	TEST_NOT_EQUAL(np, 0)
RESULT

CHECK(NamedProperty::~NamedProperty())
	delete np;
RESULT

CHECK(NamedProperty::NamedProperty(const string& name))
	np = new NamedProperty("name");
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getName(), "name")
RESULT

CHECK(NamedProperty::NamedProperty(const string& name, bool value))
	bool x = true;
  np = new NamedProperty("test", x);
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getType(), NamedProperty::BOOL)
	TEST_EQUAL(np->getName(), "test")
	TEST_EQUAL(np->getBool(), x)
RESULT

CHECK(NamedProperty::BALL_CREATE(NamedProperty) const  const )
	NamedProperty* np2 = (NamedProperty*)np->create();
	TEST_EQUAL(np2->getType(), NamedProperty::BOOL)
	TEST_EQUAL(np2->getName(), "test")
	TEST_EQUAL(np2->getBool(), true)
	delete np;
RESULT

CHECK(NamedProperty::NamedProperty(const string& name, int value))
	int x = -99;
  np = new NamedProperty("test", x);
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getType(), NamedProperty::INT)
	TEST_EQUAL(np->getName(), "test")
	TEST_EQUAL(np->getInt(), x)
	delete np;
RESULT

CHECK(NamedProperty::NamedProperty(const string& name, unsigned int value))
	unsigned int x = 99;
  np = new NamedProperty("test", x);
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getType(), NamedProperty::UNSIGNED_INT)
	TEST_EQUAL(np->getName(), "test")
	TEST_EQUAL(np->getUnsignedInt(), x)
	delete np;
RESULT

CHECK(NamedProperty::NamedProperty(const string& name, double value))
	double x = -99.9;
  np = new NamedProperty("test", x);
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getType(), NamedProperty::DOUBLE)
	TEST_EQUAL(np->getName(), "test")
	TEST_REAL_EQUAL(np->getDouble(), x)
	delete np;
RESULT

CHECK(NamedProperty::NamedProperty(const string& name, string& str))
	string x = "xxx";
  np = new NamedProperty("test", x);
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getType(), NamedProperty::STRING)
	TEST_EQUAL(np->getName(), "test")
	TEST_EQUAL(np->getString(), x)
	delete np;
RESULT

CHECK(NamedProperty::NamedProperty(const string& name, PersistentObject& po))
	PersistentObject x;
  np = new NamedProperty("test", x);
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getType(), NamedProperty::OBJECT)
	TEST_EQUAL(np->getName(), "test")
	TEST_EQUAL(np->getObject(), &x)
	delete np;
RESULT

CHECK(NamedPr operty::NamedProperty(const string& name, float value))
	float x = -99.9;
  np = new NamedProperty("test", x);
	TEST_NOT_EQUAL(np, 0)
	TEST_EQUAL(np->getType(), NamedProperty::FLOAT)
	TEST_EQUAL(np->getName(), "test")
	TEST_REAL_EQUAL(np->getFloat(), x)
RESULT

CHECK(NamedProperty::NamedProperty(const NamedProperty&))
	float x = -99.9;
	NamedProperty np2(*np);
	TEST_EQUAL(np2.getType(), NamedProperty::FLOAT)
	TEST_EQUAL(np2.getName(), "test")
	TEST_REAL_EQUAL(np2.getFloat(), x)
	
	NamedProperty np3(String("TESTPROP"), String("STR"));
	TEST_EQUAL(np3.getType(), NamedProperty::STRING)
	TEST_EQUAL(np3.getString(), "STR")
	NamedProperty np4(np3);
	TEST_EQUAL(np4.getType(), NamedProperty::STRING)
	TEST_EQUAL(np4.getString(), "STR")
	np3.clear();
	TEST_EQUAL(np3.getType(), NamedProperty::NONE)
	TEST_EQUAL(np4.getType(), NamedProperty::STRING)
	TEST_EQUAL(np4.getString(), "STR")
	np4.clear();
	TEST_EQUAL(np4.getType(), NamedProperty::NONE)
RESULT

String filename;
using std::ofstream;
using std::ios;
using namespace RTTI;
TextPersistenceManager pm;
pm.registerClass(getStreamName<NamedProperty>(), getNew<NamedProperty>);

CHECK(NamedProperty::persistentWrite(PersistenceManager& pm, const char* name = "") const )
	NEW_TMP_FILE(filename)
	ofstream  ofile(filename.c_str(), File::OUT);
	pm.setOstream(ofile);
	*np >> pm;
	ofile.close();	
	TEST_FILE_REGEXP(filename.c_str(), "data/PropertyManager_test/NamedProperty_test_Float11.txt")
	delete np;

	Protein protein("PROTEIN1");
	np = new NamedProperty("test2", protein);
	NEW_TMP_FILE(filename)
	ofile.open(filename.c_str());
	pm.setOstream(ofile);
	*np >> pm;
	ofile.close();	
	TEST_FILE_REGEXP(filename.c_str(), "data/PropertyManager_test/NamedProperty_test_Object11.txt")

	np = new NamedProperty("test3");
	NEW_TMP_FILE(filename)
	ofile.open(filename.c_str());
	pm.setOstream(ofile);
	*np >> pm;
	ofile.close();	
	TEST_FILE_REGEXP(filename.c_str(), "data/PropertyManager_test/NamedProperty_test_None11.txt")

	string s("titel");
	np = new NamedProperty("test4", s);
	NEW_TMP_FILE(filename)
	ofile.open(filename.c_str());
	pm.setOstream(ofile);
	*np >> pm;
	ofile.close();	
	TEST_FILE_REGEXP(filename.c_str(), "data/PropertyManager_test/NamedProperty_test_String11.txt")
RESULT

CHECK(NamedProperty::persistentRead(PersistenceManager& pm))
	NamedProperty np;
	PersistentObject* ptr;
	ifstream  ifile("data/PropertyManager_test/NamedProperty_test_Float1.txt");
	pm.setIstream(ifile);

	ptr = pm.readObject();
	ifile.close();
	TEST_NOT_EQUAL(ptr, 0)
	if (ptr != 0)
	{
		TEST_EQUAL(isKindOf<NamedProperty>(*ptr), true)
		if (isKindOf<NamedProperty>(*ptr))
		{
			NamedProperty* pers_a = castTo<NamedProperty>(*ptr);
			TEST_EQUAL(pers_a->getType(), NamedProperty::FLOAT)
			TEST_EQUAL(pers_a->getName(), "test")
			TEST_REAL_EQUAL(pers_a->getFloat(), (float)-99.9)
		}
	}

	// due to some problems in the IRIX/CC fstream implementation....
	ifile.clear();
	ifile.open("data/PropertyManager_test/NamedProperty_test_Object1.txt");
	ptr = pm.readObject();
	ifile.close();

	TEST_NOT_EQUAL(ptr, 0)
	if (ptr != 0)
	{
		TEST_EQUAL(isKindOf<NamedProperty>(*ptr), true)
		if (isKindOf<NamedProperty>(*ptr))
		{
			NamedProperty* pers_a = castTo<NamedProperty>(*ptr);
			TEST_EQUAL(pers_a->getType(), NamedProperty::OBJECT)
			TEST_EQUAL(pers_a->getName(), "test2")
			TEST_NOT_EQUAL(pers_a->getObject(), 0)
		}
	}
	
	// due to some problems in the IRIX/CC fstream implementation....
	ifile.clear();
	ifile.open("data/PropertyManager_test/NamedProperty_test_None1.txt");
	ptr = pm.readObject();
	ifile.close();
	TEST_NOT_EQUAL(ptr, 0)
	if (ptr != 0)
	{
		TEST_EQUAL(isKindOf<NamedProperty>(*ptr), true)
		if (isKindOf<NamedProperty>(*ptr))
		{
			NamedProperty* pers_a = castTo<NamedProperty>(*ptr);
			TEST_EQUAL(pers_a->getType(), NamedProperty::NONE)
			TEST_EQUAL(pers_a->getName(), "test3")
		}
	}

	// due to some problems in the IRIX/CC fstream implementation....
	ifile.clear();
	ifile.open("data/PropertyManager_test/NamedProperty_test_String1.txt");
	ptr = pm.readObject();
	ifile.close();

	TEST_NOT_EQUAL(ptr, 0)
	if (ptr != 0)
	{
		TEST_EQUAL(isKindOf<NamedProperty>(*ptr), true)
		if (isKindOf<NamedProperty>(*ptr))
		{
			NamedProperty* pers_a = castTo<NamedProperty>(*ptr);
			TEST_EQUAL(pers_a->getType(), NamedProperty::STRING)
			TEST_EQUAL(pers_a->getString(), "titel")
			TEST_EQUAL(pers_a->getName(), "test4")
		}
	}
RESULT

CHECK(NamedProperty::getType() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getName() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getBool() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getInt() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getFloat() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getDouble() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getUnsignedInt() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getObject() const )
  //TESTED ABOVE
RESULT

CHECK(NamedProperty::getString() const )
  //TESTED ABOVE
RESULT

PropertyManager* p;
CHECK(PropertyManager())
	p = new PropertyManager();
	TEST_NOT_EQUAL(p, 0)
RESULT

CHECK(~PropertyManager())
	delete p;
RESULT

PropertyManager m;

CHECK(setProperty(String&, int))
  TEST_EQUAL(m.hasProperty(0), false)
  TEST_EQUAL(m.countProperties(), 0)

	TEST_EQUAL(m.hasProperty("TEST_PROP"), false)
	m.setProperty("TEST_PROP", (unsigned int)123456);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getUnsignedInt(), 123456)
RESULT

CHECK(PropertyManager::PropertyManager(const PropertyManager& property_manager, bool deep = true))
	PropertyManager* p2;
	p2 = new PropertyManager(m);
	TEST_NOT_EQUAL(p2, 0)
	TEST_EQUAL(p2->hasProperty("TEST_PROP"), true)
	TEST_EQUAL(p2->getProperty("TEST_PROP").getUnsignedInt(), 123456)	
RESULT

CHECK(PropertyManager::clear())
	PropertyManager p2(m);
	p2.clear();
	TEST_EQUAL(p2.hasProperty("TEST_PROP"), false)
RESULT

CHECK(PropertyManager::destroy())
	PropertyManager p2(m);
	p2.destroy();
	TEST_EQUAL(p2.hasProperty("TEST_PROP"), false)
RESULT

CHECK(PropertyManager::set(const PropertyManager& property_manager, bool deep = true))
  TEST_EQUAL(m.countProperties(), 1)
	PropertyManager p2;
	p2.set(m);
	TEST_EQUAL(p2.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(p2.getProperty("TEST_PROP").getUnsignedInt(), 123456)	
RESULT

CHECK(PropertyManager::PropertyManager& operator = (const PropertyManager& property_manager))
	PropertyManager p2;
	p2 = m;
	TEST_EQUAL(p2.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(p2.getProperty("TEST_PROP").getUnsignedInt(), 123456)	
RESULT

CHECK(PropertyManager::get(PropertyManager& property_manager, bool deep = true) const )
	PropertyManager p2;
	m.get(p2);
	TEST_EQUAL(p2.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(p2.getProperty("TEST_PROP").getUnsignedInt(), 123456)	
RESULT

CHECK(PropertyManager::swap(PropertyManager& property_manager))
	PropertyManager m2;
	m2.setProperty("PROP1", (float)4.56);
	m2.setProperty("PROP2", (string)"test");
	m2.swap(m);
	TEST_EQUAL(m2.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m2.getProperty("TEST_PROP").getUnsignedInt(), 123456)	
	TEST_EQUAL(m2.hasProperty("PROP1"), false)
	TEST_EQUAL(m2.hasProperty("PROP2"), false)

	TEST_EQUAL(m.hasProperty("PROP1"), true)
	TEST_EQUAL(m.hasProperty("PROP2"), true)
	TEST_EQUAL(m.hasProperty("TEST_PROP"), false)
	TEST_REAL_EQUAL(m.getProperty("PROP1").getFloat(), 4.56)	
	TEST_EQUAL(m.getProperty("PROP2").getString(), "test")
	m2.swap(m);
RESULT

CHECK(PropertyManager::getBitVector())
  TEST_EQUAL(m.getBitVector().getBit(0), false)
	m.getBitVector().setBit(0, true);
  TEST_EQUAL(m.getBitVector().getBit(0), true)
RESULT

CHECK(PropertyManager::getBitVector() const )
	PropertyManager m;
  m.setProperty(5);

  const PropertyManager m2;
	TEST_EXCEPTION(Exception::IndexOverflow, m2.getBitVector().getBit(0))

  const PropertyManager m3(m);
  TEST_EQUAL(m3.getBitVector().getBit(0), false)
RESULT

CHECK(PropertyManager:: operator BitVector& ())
	PropertyManager m;
  m.setProperty(5);

	BitVector b = (BitVector) m;
  TEST_EQUAL(b.getBit(0), false)
  TEST_EQUAL(b.getBit(5), true)

	m.setProperty(0); 
  TEST_EQUAL(b.getBit(5), true)
  TEST_EQUAL(b.getBit(0), false)
RESULT

CHECK(PropertyManager::setProperty(Property property))
	PropertyManager m;
  m.setProperty(1);
  TEST_EQUAL(m.getBitVector().getBit(1), true)
RESULT

CHECK(PropertyManager::clearProperty(Property property))
	PropertyManager m;
  m.setProperty(1);
  m.clearProperty(1);
  TEST_EQUAL(m.getBitVector().getBit(1), false)
RESULT

CHECK(PropertyManager::toggleProperty(Property property))
	PropertyManager m;
  m.toggleProperty(1);
  TEST_EQUAL(m.getBitVector().getBit(1), true)
  m.toggleProperty(1);
  TEST_EQUAL(m.getBitVector().getBit(1), false)
RESULT

CHECK(PropertyManager::countProperties() const )
  TEST_EQUAL(m.countProperties(), 2)
	m.clear();
  TEST_EQUAL(m.countProperties(), 0)
  TEST_EQUAL(m.countNamedProperties(), 0)
RESULT

CHECK(PropertyManager::setProperty(const NamedProperty& property))
	NamedProperty x("test", 1);
	PropertyManager m;
	m.setProperty(x);
	TEST_EQUAL(m.hasProperty("test"), true)
	TEST_EQUAL(m.getProperty("test").getInt(), 1)
	TEST_EQUAL(m.getProperty("test").getType(), NamedProperty::INT)
RESULT

CHECK(PropertyManager::setProperty(const string& name))
	PropertyManager m;
	m.setProperty("TEST_PROP");
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getBool(), false)
	TEST_EQUAL(m.getProperty("TEST_PROP").getType(), NamedProperty::NONE)
RESULT

CHECK(PropertyManager::setProperty(const string& name, bool value))
	PropertyManager m;
	m.setProperty("TEST_PROP", true);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getBool(), true)
RESULT

CHECK(PropertyManager::setProperty(const string& name, int value))
	PropertyManager m;
	m.setProperty("TEST_PROP", (int)-56789);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getInt(), -56789)
RESULT

CHECK(PropertyManager::setProperty(const string& name, unsigned int value))
	PropertyManager m;
	m.setProperty("TEST_PROP", (unsigned int)56789);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getUnsignedInt(), 56789)
RESULT

CHECK(setProperty(String&, float))
	PropertyManager m;
	m.setProperty("TEST_PROP", (float)0.56789);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_REAL_EQUAL(m.getProperty("TEST_PROP").getFloat(), 0.56789)
RESULT

CHECK(PropertyManager::setProperty(const string& name, double value))
	PropertyManager m;
	m.setProperty("TEST_PROP", (double)0.56789);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_REAL_EQUAL(m.getProperty("TEST_PROP").getDouble(), 0.56789)
RESULT

CHECK(PropertyManager::setProperty(const string& name, const string& value))
	PropertyManager m;
	m.setProperty("TEST_PROP", (string)"xxx");
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getString(), "xxx")
RESULT

CHECK(PropertyManager::setProperty(const string& name, const PersistentObject& value))
	PropertyManager m;
	PersistentObject po;
	m.setProperty("TEST_PROP", po);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getObject(), &po)
RESULT

CHECK(PropertyManager::getProperty(const string& name) const )
	PropertyManager m;
	PersistentObject po;
	TEST_EQUAL(m.getProperty("TEST_PROP").getObject(), 0)
	TEST_EQUAL(m.getProperty("TEST_PROP").getType(), NamedProperty::NONE)
	m.setProperty("TEST_PROP", po);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	TEST_EQUAL(m.getProperty("TEST_PROP").getObject(), &po)
RESULT

CHECK(PropertyManager::clearProperty(const string& name))
	PropertyManager m;
	PersistentObject po;
	m.setProperty("TEST_PROP", po);
	TEST_EQUAL(m.hasProperty("TEST_PROP"), true)
	m.clearProperty("");
	m.clearProperty("TEST_PROP");
	TEST_EQUAL(m.hasProperty("TEST_PROP"), false)
RESULT

CHECK(PropertyManager::countNamedProperties() const )
	PropertyManager m;
	TEST_EQUAL(m.countNamedProperties(), 0)
	m.setProperty("TEST_PROP1", 0);
	TEST_EQUAL(m.countNamedProperties(), 1)
	m.setProperty("TEST_PROP2", string("ASD"));
	TEST_EQUAL(m.countNamedProperties(), 2)
	m.clearProperty("TEST_PROP2");
	TEST_EQUAL(m.countNamedProperties(), 1)
	m.setProperty("TEST_PROP1", "");
	TEST_EQUAL(m.countNamedProperties(), 1)
RESULT

CHECK(PropertyManager::getNamedProperty(Position index) const)
	PropertyManager m;
	m.setProperty("TEST_PROP1", 123);
	m.setProperty("TEST_PROP2", string("ASD"));
	m.setProperty("TEST_PROP3", true);
	TEST_EQUAL(m.countNamedProperties(), 3)

	const PropertyManager& c_m(m);
	TEST_EQUAL(c_m.getNamedProperty(0).getInt(), 123)
	TEST_EQUAL(c_m.getNamedProperty(1).getString(), "ASD")
	TEST_EQUAL(c_m.getNamedProperty(2).getBool(), true)
	TEST_EXCEPTION(Exception::IndexOverflow, c_m.getNamedProperty(3))
RESULT

CHECK(PropertyManager::getNamedProperty(Position index))
	PropertyManager m;
	m.setProperty("TEST_PROP1", 123);
	m.setProperty("TEST_PROP2", string("ASD"));
	m.setProperty("TEST_PROP3", true);
	TEST_EQUAL(m.countNamedProperties(), 3)

	TEST_EQUAL(m.getNamedProperty(0).getInt(), 123)
	TEST_EQUAL(m.getNamedProperty(1).getString(), "ASD")
	TEST_EQUAL(m.getNamedProperty(2).getBool(), true)
	TEST_EXCEPTION(Exception::IndexOverflow, m.getNamedProperty(3))
RESULT

CHECK(PropertyManager::hasProperty(Property property) const )
	PropertyManager m;
	TEST_EQUAL(m.hasProperty(1), false)
	TEST_EQUAL(m.hasProperty(0), false)
	m.setProperty(0);
	TEST_EQUAL(m.hasProperty(0), true)
	m.clear();
	TEST_EQUAL(m.hasProperty(0), false)
RESULT

CHECK(PropertyManager::hasProperty(const string& name) const )
	PropertyManager m;
	TEST_EQUAL(m.hasProperty("TEST_PROP"), false)
	TEST_EQUAL(m.hasProperty(""), false)
	m.setProperty("TEST_PROP", 0);
	m.clearProperty("TEST_PROP");
	TEST_EQUAL(m.hasProperty("TEST_PROP"), false)
RESULT

CHECK(PropertyManager::std::ostream& operator << (std::ostream& s, const PropertyManager& property_manager))
	NEW_TMP_FILE(filename)
	std::ofstream outstr(filename.c_str(), File::OUT);
	string str("test");
	PersistentObject ob;
	m.setProperty("PROP1", true);
	m.setProperty("PROP2", -12345);
	m.setProperty("PROP3", (unsigned int)12345);
	m.setProperty("PROP4", (float)1.2345);
	m.setProperty("PROP5", (double) 2.345);
	m.setProperty("PROP6", str);
	TEST_EQUAL(m.getProperty("PROP6").getString(), "test")
	m.setProperty("PROP7", ob);
	m.setProperty("PROP8");
	m.setProperty(0);
	m.setProperty(2);
	outstr << m;
	outstr.close();
	TEST_FILE_REGEXP(filename.c_str(), "data/PropertyManager_test/PropertyManager_test_ostream1.txt")
RESULT


CHECK(PropertyManager::std::istream& operator >> (std::istream& s, PropertyManager& property_manager))
	std::ifstream instr("data/PropertyManager_test/PropertyManager_test_ostream2.txt");
	PropertyManager m;
	TEST_EQUAL(m.countNamedProperties(), 0)
	instr >> m;
	instr.close();
	TEST_EQUAL(m.countNamedProperties(), 8)
	TEST_EQUAL(m.hasProperty("PROP1"), true)
	TEST_EQUAL(m.hasProperty("PROP2"), true)
	TEST_EQUAL(m.hasProperty("PROP3"), true)
	TEST_EQUAL(m.hasProperty("PROP4"), true)
	TEST_EQUAL(m.hasProperty("PROP5"), true)
	TEST_EQUAL(m.hasProperty("PROP6"), true)
	TEST_EQUAL(m.hasProperty("PROP7"), true)
	TEST_EQUAL(m.hasProperty("PROP8"), true)
	TEST_EQUAL(m.hasProperty("TEST_PROP"), false)
	TEST_EQUAL(m.getProperty("PROP1").getBool(), true)	
	TEST_EQUAL(m.getProperty("PROP2").getInt(), -12345)
	TEST_EQUAL(m.getProperty("PROP3").getUnsignedInt(), 12345)
	TEST_REAL_EQUAL(m.getProperty("PROP4").getFloat(), 1.2345)
	TEST_REAL_EQUAL(m.getProperty("PROP5").getDouble(), 2.345)
	TEST_EQUAL(m.getProperty("PROP6").getString(), "test")
	TEST_NOT_EQUAL(m.getProperty("PROP7").getObject(), 0) 
	TEST_EQUAL(m.countNamedProperties(), 8);
	TEST_EQUAL(m.getBitVector().getBit(0), true)
	TEST_EQUAL(m.getBitVector().getBit(1), false)
	TEST_EQUAL(m.getBitVector().getBit(2), true)
RESULT


CHECK(PropertyManager::write(PersistenceManager& pm) const )
	NEW_TMP_FILE(filename)
	ofstream  ofile(filename.c_str(), File::OUT);
	pm.setOstream(ofile);
	m.write(pm);
	ofile.close();	
	TEST_FILE_REGEXP(filename.c_str(), "data/PropertyManager_test/PropertyManager_test_write.txt")
RESULT


CHECK(PropertyManager::read(PersistenceManager& pm))
	PropertyManager m;
	ifstream  ifile("data/PropertyManager_test/PropertyManager_test_read.txt");
	pm.setIstream(ifile);
	TEST_EQUAL(m.read(pm), true)
	TEST_EQUAL(m.hasProperty("PROP1"), true)
	TEST_EQUAL(m.hasProperty("PROP2"), true)
	TEST_EQUAL(m.hasProperty("PROP3"), true)
	TEST_EQUAL(m.hasProperty("PROP4"), true)
	TEST_EQUAL(m.hasProperty("PROP5"), true)
	TEST_EQUAL(m.hasProperty("PROP6"), true)
	TEST_EQUAL(m.hasProperty("PROP7"), true)
	TEST_EQUAL(m.hasProperty("PROP8"), true)
	TEST_EQUAL(m.hasProperty("TEST_PROP"), false)
	TEST_EQUAL(m.getProperty("PROP1").getBool(), true)	
	TEST_EQUAL(m.getProperty("PROP2").getInt(), -12345)
	TEST_EQUAL(m.getProperty("PROP3").getUnsignedInt(), 12345)
	TEST_REAL_EQUAL(m.getProperty("PROP4").getFloat(), 1.2345)
	TEST_REAL_EQUAL(m.getProperty("PROP5").getDouble(), 2.345)
	TEST_EQUAL(m.getProperty("PROP6").getString(), "test")
	TEST_NOT_EQUAL(m.getProperty("PROP7").getObject(), 0)
	TEST_EQUAL(m.countNamedProperties(), 8);
	TEST_EQUAL(m.getBitVector().getBit(0), true)
	TEST_EQUAL(m.getBitVector().getBit(1), false)
	TEST_EQUAL(m.getBitVector().getBit(2), true)
	ifile.close();
RESULT


CHECK(PropertyManager::isValid() const )
	TEST_EQUAL(m.isValid(), true)
RESULT

CHECK(PropertyManager::dump(std::ostream& s = std::cout, Size depth = 0) const )
	NEW_TMP_FILE(filename)
	std::ofstream outstr(filename.c_str(), File::OUT);
	m.dump(outstr); 
	TEST_FILE_REGEXP(filename.c_str(), "data/PropertyManager_test/PropertyManager_test_dump.txt")
RESULT

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
END_TEST
