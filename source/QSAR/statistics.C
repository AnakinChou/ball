// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// 

#include <BALL/QSAR/statistics.h>
#include <iostream>

using namespace BALL::QSAR;
using namespace std;

void Statistics::scaling(vector<vector<double> >& m)
{
	for (unsigned int i=0; i<m.size(); i++)
	{
		scaling(m[i]);
	}
}


void Statistics::scaling(vector<double>& v)
{
	double std=sqrt(getVariance(v));
	if (std==0) {return;} // if all values==0, do not change anything
	for(unsigned int i=0; i<v.size(); i++)
	{
		v[i]/=std;
	}
}


void Statistics::centering(vector<vector<double> >& m)
{
	for (unsigned int i=0; i<m.size(); i++)
	{
		centering(m[i]);
	}
}


void Statistics::centering(vector<double>& v)
{
	double mean=getMean(v);
	double std=sqrt(getVariance(v,mean));
	if (std==0) {return;} // if all values==0, do not change anything
	for(unsigned int i=0; i<v.size(); i++)
	{
		v[i]=(v[i]-mean)/std;
	}
}


void Statistics::centering(vector<double>& v, double& mean, double& std)
{
	mean=getMean(v);
	std=sqrt(getVariance(v,mean));
	if (std==0) {return;} // if all values==0, do not change anything
	for(unsigned int i=0; i<v.size(); i++)
	{
		v[i]=(v[i]-mean)/std;
	}
}


double Statistics::getVariance(const vector<double>& v, double mean)
{
	if (mean==-1) {	mean=getMean(v); }
	double sum_of_squares=0;
	for(uint i=0; i<v.size(); i++)
	{
		sum_of_squares+=(v[i]-mean)*(v[i]-mean);
	}
	return sum_of_squares/(v.size()-1);
}


double Statistics::getStddev(const vector<double>& v, double mean)
{
	double var = getVariance(v,mean);
	return sqrt(var);
}


double Statistics::getCovariance(const vector<double>& v1, const vector<double>& v2, double mean1, double mean2)
{
	if (mean1==-1) {mean1=getMean(v1);}
	if (mean2==-1) {mean2=getMean(v2);}
	double sum_of_squares=0;
	for(uint i=0; i<v1.size() && i<v2.size(); i++)
	{
		sum_of_squares+=(v1[i]-mean1)*(v2[i]-mean2);
	}
	return sum_of_squares/(v1.size()-1);
}



double Statistics::getMean(const vector<double>& v)
{
	double sum=0;
	for(uint i=0; i<v.size(); i++)
	{
		sum+=v[i];
	}
	return sum/v.size();
}



//---------------- methods for calculating mean, covar, var of matrix-ROWS  ----------


double Statistics::getRowCovariance(const vector<vector<double> >& v, int row1, int row2, double mean1, double mean2, SortedList<int>* features_to_use)
{
	if (mean1==-1) {mean1=getRowMean(v,row1,features_to_use);}
	if (mean2==-1) {mean2=getRowMean(v,row2,features_to_use);}
	double sum_of_squares=0;
	int size=v.size();
	SortedList<int>::iterator it;
	if(features_to_use!=0) 
	{
		it=features_to_use->begin();
		size=features_to_use->size();
	}	
	
	for(uint i=0; i<v.size(); i++)
	{
		if(features_to_use!=0 && *it!=(int)i) continue;
		sum_of_squares+=(v[i][row1]-mean1)*(v[i][row2]-mean2);
		if(features_to_use!=0) it++;
	}
	return sum_of_squares/(size-1);
}

double Statistics::getRowMean(const vector<vector<double> >& v, int row, SortedList<int>* features_to_use)
{
	double sum=0;
	int size=v.size();
	SortedList<int>::iterator it;
	if(features_to_use!=0) 
	{
		it=features_to_use->begin();
		size=features_to_use->size();
	}	
	
	for(uint i=0; i<v.size(); i++)
	{
		if(features_to_use!=0 && *it!=(int)i) continue;
		sum+=v[i][row];
		if(features_to_use!=0) it++;
	}
	return sum/size;
}

double Statistics::getRowVariance(const vector<vector<double> >& v, int row, double mean, SortedList<int>* features_to_use)
{
	if (mean==-1) {	mean=getRowMean(v,row,features_to_use); }
	double sum_of_squares=0;
	int size=v.size();
	SortedList<int>::iterator it;
	if(features_to_use!=0) 
	{
		it=features_to_use->begin();
		size=features_to_use->size();
	}
	
	for(uint i=0; i<v.size(); i++)
	{
		if(features_to_use!=0 && *it!=(int)i) continue;
		sum_of_squares+=(v[i][row]-mean)*(v[i][row]-mean);
		if(features_to_use!=0) it++;
	}
	return sum_of_squares/(size-1);
}

double Statistics::getRowStddev(const vector<vector<double> >& v, int row, double mean, SortedList<int>* features_to_use)
{
	double var = getRowVariance(v,row,mean,features_to_use);
	return sqrt(var);
}


// -----------------------------------------------------------------


void Statistics::centering(Matrix<double>& m)
{
	for (int i=1; i<=m.Ncols(); i++)
	{
		centering(m, i);
	}
}


void Statistics::centering(Matrix<double>& m, int col)
{
	double mean=getMean(m, col);
	double std=sqrt(getVariance(m, col, mean));
	if (std==0) {return;} // if all values==0, do not change anything
	for(int i=1; i<=m.Nrows(); i++)
	{
		m(i,col)=(m(i,col)-mean)/std;
	}
}

double Statistics::getMean(const Matrix<double>& m, int col)
{
	double sum=0;
	for(int i=1; i<=m.Nrows(); i++)
	{
		sum+=m(i,col);
	}
	return sum/m.Nrows();
}

double Statistics::getVariance(const Matrix<double>& m, int col, double mean)
{
	if (mean==-1) {	mean=getMean(m,col); }
	double sum_of_squares=0;
	for(int i=1; i<=m.Nrows(); i++)
	{
		sum_of_squares+=pow(m(i,col)-mean,2);
	}
	return sum_of_squares/(m.Nrows()-1);
}

double Statistics::getStddev(const Matrix<double>& m, int col, double mean)
{
	double d = getVariance(m,col,mean);
	return sqrt(d);
}

double Statistics::getCovariance(const Matrix<double>& m, int col1, int col2, double mean1, double mean2)
{
	if (mean1==-1) {mean1=getMean(m,col1);}
	if (mean2==-1) {mean2=getMean(m,col2);}
	double sum_of_squares=0;
	for(int i=1; i<=m.Nrows(); i++)
	{
		sum_of_squares+=(m(i,col1)-mean1)*(m(i,col2)-mean2);
	}
	return sum_of_squares/(m.Nrows()-1);
}


double Statistics::sq(const Matrix<double>& m, int col, double mean)
{
	if (mean==-1) {	mean=getMean(m,col); }
	double sum_of_squares=0;
	for(int i=1; i<=m.Nrows(); i++)
	{
		sum_of_squares+=pow(m(i,col)-mean,2);
	}
	return sum_of_squares;
}

double Statistics::euclNorm(const Vector<double>& cv)
{
	return sqrt(scalarProduct(cv));
}


double Statistics::scalarProduct(const Vector<double>& cv)
{
	double n=0;
	for(uint i=1; i<=cv.getSize();i++)
	{
		n+=cv(i)*cv(i);
	}
	return n;
}


double Statistics::euclDistance(const Vector<double>& c1, const Vector<double>& c2)
{
	double n=0;
	for(uint i=1; i<=c1.getSize();i++)
	{
		n+=pow((c1(i)-c2(i)),2);
	}
	return sqrt(n);
}

//---------------------------


double Statistics::distance(const Matrix<double>& m, int& row1, int& row2, double& p)
{
	double dist=0;
	for (int j=1; j<=m.Ncols(); j++)
	{
		dist+=m(row1,j)*m(row2,j);
		
	}
		
	int i_p = static_cast <int> (p);
	if(i_p != p) // if a root of dist should be taken, then dist may not be negative
	{
		dist = abs(dist);
	}
	return pow(dist,p);
}


double Statistics::distance(const Matrix<double>& m1, const Matrix<double>& m2, int& row1, int& row2, double& p)
{
	if(m1.Ncols()!=m2.Ncols()) 
	{
		cout << "Matrices must have the same number of columns!!"<<endl; return 0;
	}
	
	double dist=0;
	for (int j=1; j<=m1.Ncols(); j++)
	{
		dist+=m1(row1,j)*m2(row2,j);
	}
		
	int i_p = static_cast <int> (p);
	if(i_p != p) // if a root of dist should be taken, then dist may not be negative
	{
		dist = abs(dist);
	}
	return pow(dist,p);
}


double Statistics::distance(const Matrix<double>& m1, const Matrix<double>& m2, int& row1, int& row2, String& f, String& g)
{
	if(m1.Ncols()!=m2.Ncols()) 
	{
		cout << "Matrices must have the same number of columns!!"<<endl; return 0;
	}
	
	double dist=0;
	for (int j=1; j<=m1.Ncols(); j++)
	{
		String var="";
		var = var+"x1="+String(m1(row1,j))+";x2="+String(m2(row2,j))+";";
	//	cout<<"f= "<<var+f<<endl;
		ParsedFunction<double> pf(var+f);
		dist+=pf(0);
	}	
	String var2="";
	var2 = var2+"sum="+String(dist)+";";
	//cout<<"g= "<<var+g<<endl;
	ParsedFunction<double> pf2(var2+g);
	return pf2(0);
}


double Statistics::euclDistance(const Matrix<double>& m1, const Matrix<double>& m2, int row1, int row2)
{
	if(m1.Ncols()!=m2.Ncols()) 
	{
		cout << "Matrices must have the same number of columns!!"<<endl; return 0;
	}
	
	double dist=0;
	for (int j=1; j<=m1.Ncols(); j++)
	{
		dist+=pow(m1(row1,j)-m2(row2,j),2);
	}	
	return sqrt(dist);
}



