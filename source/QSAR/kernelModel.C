// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// 

#include <BALL/QSAR/kernelModel.h>
#include <newmatio.h>

using namespace BALL::QSAR; 




KernelModel::KernelModel(const QSARData& q, int k_type, double p1, double p2) : NonLinearModel(q)
{
	kernel=new Kernel(this, k_type, p1, p2);
}
		
				
KernelModel::KernelModel(const QSARData& q, String f, String g) : NonLinearModel(q)
{
	kernel=new Kernel(this,f,g);
}
		
		
KernelModel::KernelModel(const QSARData& q, RowVector& w) : NonLinearModel(q)
{
	kernel=new Kernel(this,w);
}


KernelModel::KernelModel(const QSARData& q, const LinearModel& lm, int column) : NonLinearModel(q)
{
	kernel=new Kernel(this,lm,column);
}


KernelModel::~KernelModel()
{
	delete kernel;
}


void KernelModel::operator=(const Model& m)
{
	Model::operator=(m);	
	const KernelModel* km = static_cast<const KernelModel*>(&m);
	kernel->type = km->kernel->type;
	kernel->par1 = km->kernel->par1;
	kernel->par2 = km->kernel->par2;
	kernel->equation1 = km->kernel->equation1;
	kernel->equation2 = km->kernel->equation2;
}


void KernelModel::saveToFile(string filename)
{
	if(training_result_.Nrows()==0 && type_!="SVR")
	{
		throw Exception::InconsistentUsage(__FILE__,__LINE__,"Model must have been trained before the results can be saved to a file!");
	}
	ofstream out(filename.c_str());
	
	const Matrix* coeffErrors = validation->getCoefficientErrors();
	bool stderr=0;
	if(coeffErrors->Ncols()!=0)
	{
		stderr=1;
	}
	bool centered_data = 0;
	bool centered_y = 0;
	if(descriptor_transformations_.Ncols()!=0)
	{
		centered_data=1;
		if(y_transformations_.Ncols()!=0)
		{
			centered_y=1;
		}
	}
	
	int sel_features=descriptor_IDs_.size();
	if(sel_features==0)
	{
		sel_features = data->getNoDescriptors();
	}
	
	out<<"# model-type_\tno of featues in input data\tselected featues\tno of response variables\tcentered descriptors?\tcentered response?\tno of substances"<<endl;
	out<<type_<<"\t"<<data->getNoDescriptors()<<"\t"<<sel_features<<"\t"<<Y_.Ncols()<<"\t"<<centered_data<<"\t"<<centered_y<<"\t"<<descriptor_matrix_.Nrows()<<"\n\n";
	
	out<<"# kernel-type_\tkernel-par1\tkernel-par2\n";
	out<<kernel->type<<"\t";	/// write kernel parameters
	if(kernel->type!=4)
	{
		out<<kernel->par1<<"\t"<<kernel->par2<<"\n";
	}
	else
	{
		out<<kernel->equation1<<"\t"<<kernel->equation2<<endl;
	}
	
	out<<endl<<"# model-parameters"<<endl;  /// write model parameters 
	vector<double> v = getParameters();
	for(unsigned int i=0;i<v.size();i++)
	{
		out<<v[i]<<"\t";
	}
	out<<endl;
	
	if(centered_y) /// write information about transformation of result
	{
		out<<endl;
		for(int i=1;i<=y_transformations_.Ncols();i++)
		{
			out<<y_transformations_(1,i)<<"\t"<<y_transformations_(2,i)<<"\n";
		}
	}	
		
	out<<"\n# ID\tdescriptor-name\t";
	if(centered_data)
	{
		out<<"mean of desc.\tstddev of desc.\t";
	}
	if(stderr)
	{
		out<<"stderr(s) of coeff.";
	}
	out<<endl;  
	
	/// write (selected) descriptors and information about their transformation
	if(!descriptor_IDs_.empty())
	{
		descriptor_IDs_.front();
		for(int i=0; i<descriptor_matrix_.Ncols() && descriptor_IDs_.hasNext();i++)
		{
			out<<String(descriptor_IDs_.next())<<"\t"<<descriptor_names_[i]<<"\t";
			
			if(centered_data)
			{
				out<<descriptor_transformations_(1,i+1)<<"\t"<<descriptor_transformations_(2,i+1)<<"\t";
			}
			out <<"\n";
		}
	}
	else
	{
		for(int i=0; i<descriptor_matrix_.Ncols();i++)
		{
			out<<String(i)<<"\t"<<descriptor_names_[i]<<"\t";
	
			if(centered_data)
			{
				out<<descriptor_transformations_(1,i+1)<<"\t"<<descriptor_transformations_(2,i+1)<<"\t";
			}
			out <<"\n";
		}
		
	}	
	out<<endl;
	
	if(type_!="SVR") // NO training_result matrix in case of SVR
	{
		for(int i=1; i<=training_result_.Nrows();i++) /// write training result
		{
			out<<substance_names_[i-1]<<"\t";
			for(int j=1;j<=training_result_.Ncols();j++)
			{
				out<<training_result_(i,j)<<"\t";
			}
			for(int j=1; j<=coeffErrors->Ncols();j++)
			{
				out<<(*coeffErrors)(i,j)<<"\t";
			}
			out<<endl;
		}
		out<<endl;
	}
	
	out<<descriptor_matrix_<<endl; /// write descriptor matrix
	out<<K_<<endl;			/// write kernel matrix K_
	out.close();
		
}


void KernelModel::readFromFile(string filename)
{
	ifstream input(filename.c_str());
	if(!input)
	{
		throw BALL::Exception::FileNotFound(__FILE__,__LINE__,filename);
	}	
	
	String line0;
	getline(input,line0);  // skip comment line 
	getline(input,line0);  // read read line containing model specification
	
	if(line0.getField(0,"\t")!=type_)
	{
		String e = "Wrong input data! Use training data file generated by a ";
		e = e + type_ + " model !";
		throw Exception::WrongDataType(__FILE__,__LINE__,e.c_str());
	}
	
	int no_descriptors = line0.getField(2,"\t").toInt();
	int no_y = line0.getField(3,"\t").toInt();
	bool centered_data = line0.getField(4,"\t").toInt();
	bool centered_y = line0.getField(5,"\t").toInt();
	int no_substances = line0.getField(6,"\t").toInt();
	training_result_.ReSize(no_substances,no_y);
	descriptor_matrix_.ReSize(no_substances,no_descriptors);
	K_.ReSize(no_substances,no_substances);
	descriptor_names_.clear();
	substance_names_.clear();
	if(centered_data)
	{
		descriptor_transformations_.ReSize(2,no_descriptors);
	}
	getline(input,line0);  // skip empty line
	getline(input,line0);  // skip comment line
	getline(input,line0); 		/// read kernel parameters
	kernel->type = line0.getField(0,"\t").toInt();
	if(kernel->type!=4)
	{
		kernel->par1 = line0.getField(1,"\t").toDouble();
		kernel->par2 = line0.getField(2,"\t").toDouble();
	}
	else
	{
		kernel->equation1 = line0.getField(1,"\t");
		kernel->equation1 = line0.getField(1,"\t");
	}
	getline(input,line0);  // skip empty line
	getline(input,line0);  // skip comment line
	
	getline(input,line0);	   /// read model parameters
	int c = line0.countFields("\t");
	vector<double> v;
	for(int i=0; i<c; i++)
	{
		v.push_back(line0.getField(i,"\t").toDouble());
	}
	setParameters(v);
	getline(input,line0);  // skip empty line
	
	if(centered_y)  /// read information about transformation of response
	{
		y_transformations_.ReSize(2,no_y);
		for(int i=1; i<=no_y; i++)
		{
			getline(input,line0);
			y_transformations_(1,i)=line0.getField(0,"\t").toDouble();	
			y_transformations_(2,i)=line0.getField(1,"\t").toDouble();
		}
		getline(input,line0);  // skip empty line 
	}
	getline(input,line0);  // skip comment line 

	for(int i=1; i<=no_descriptors; i++) /// read descriptors and infor. about their transformation
	{
		String line;
		getline(input,line);
		unsigned int id = (unsigned int) line.getField(0,"\t").toInt();
		descriptor_IDs_.push_back(id);
		descriptor_names_.push_back(line.getField(1,"\t"));
		if(centered_data)
		{
			descriptor_transformations_(1,i)= line.getField(2,"\t").toDouble();
			descriptor_transformations_(2,i)= line.getField(3,"\t").toDouble();
		}
	}	
	getline(input,line0);  // skip empty line 
	
	if(type_!="SVR") // NO result of training within this file in case of SVR
	{
		for(int i=1; i<=no_substances; i++) /// read training result
		{
			String line;
			getline(input,line);
			substance_names_.push_back(line.getField(0,"\t"));
			for(int j=1; j<=no_y; j++)
			{
				training_result_(i,j) = line.getField(j,"\t").toDouble();
			}
		}
		getline(input,line0);  // skip empty line 
	}
	
	readMatrix(descriptor_matrix_,input,no_substances,no_descriptors);  /// read descriptor matrix
	getline(input,line0);  // skip empty line 
	readMatrix(K_,input,no_substances,no_substances); 	 /// read kernel matrix K_	
}
