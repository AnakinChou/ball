// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// 

#include <BALL/QSAR/pcrModel.h>
using namespace BALL::QSAR;



PCRModel::PCRModel(const QSARData& q, double frac_var, bool k) : LinearModel(q) 
{
	kernel_=k;
	type_="PCR";
	frac_var_=frac_var;
}

PCRModel::~PCRModel()
{
}

void PCRModel::setFracVar(double frac_var)
{
	frac_var_=frac_var;
}


void PCRModel::train()
{
	if(descriptor_matrix_.Ncols()==0)
	{
		throw Exception::InconsistentUsage(__FILE__,__LINE__,"Data must be read into the model before training!");
	}
	SymmetricMatrix X;
	if(!kernel_){X << descriptor_matrix_.t()*descriptor_matrix_;}
	else{X << descriptor_matrix_;}
	
	Matrix eigenVectors;
	DiagonalMatrix eigenValues; // newmat sorts eigenvalues and -vectors ascendingly !!
	EigenValues(X,eigenValues,eigenVectors);
	int first_eigenvector=eigenValues.Ncols();
//	double largest_eigenvalue=eigenValues(first_eigenvector);
	int last_eigenvector=first_eigenvector;

	// find the smallest eigenvector that should be taken into account

	double complete_var=eigenValues.Sum();
	double explained_var=0;
	int cols=0; 
	
	if(complete_var==0)
	{
		throw Exception::NoPCAVariance(__FILE__,__LINE__,"No variance present to be explained by PCA!");
	}
		
	for (; last_eigenvector>=1 && cols<descriptor_matrix_.Nrows()-1 && explained_var/complete_var<frac_var_ ; last_eigenvector--) 
	{
		explained_var+=eigenValues(last_eigenvector);
		cols++;
	}
	last_eigenvector++;
		
	// create a matrix that takes the latente variables, that are generated by use of the selected eigenvectors
	Matrix latenteVariables(descriptor_matrix_.Nrows(),cols);
	Matrix ev(descriptor_matrix_.Ncols(),cols); // the significant eigenvectors
	
	int c=1;
 	for (int i=first_eigenvector; i>=last_eigenvector ; i--)
 	{
 		latenteVariables.Column(c)=descriptor_matrix_*eigenVectors.Column(i);
		ev.Column(c)=eigenVectors.Column(i);
		c++;
 	}

	RRModel m(*data);
	m.descriptor_matrix_=latenteVariables;
	m.Y_=Y_;
	m.train();

	//result of MLR is a linear combination of latente variables 
	// = column with length=no of latente variables => matrix for more than one modelled activity

	training_result_ = ev*(*m.getTrainingResult());
	
}


void PCRModel::setParameters(vector<double>& v)
{
	if(v.size()!=1)
	{
		String c = "Wrong number of model parameters! Needed: 1;";
		c = c+" given: "+String(v.size());
		throw Exception::ModelParameterError(__FILE__,__LINE__,c.c_str());
	}
	frac_var_ = v[0];
}


vector<double> PCRModel::getParameters() const
{
	vector<double> d;
	d.push_back(frac_var_);
	return d;
}
