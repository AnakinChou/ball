#ifndef BALL_LINALG_MATRIXBASICFUNCTIONS_IC
#define BALL_LINALG_MATRIXBASICFUNCTIONS_IC

#include <BALL/DATATYPE/string.h>

namespace BALL 
{

typedef std::complex<float>  ComplexFloat;
typedef std::complex<double> ComplexDouble;

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::clear()
{
	data_.clear();
	row_major_ = true;
	n_ = 0;
	m_ = 0;
}

template <class valuetype, class mtraits>
std::vector<valuetype> Matrix<valuetype, mtraits>::getData() const
	throw()
{
	return data_;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::setData(const std::vector<valuetype>& new_data)
	throw(Exception::MatrixHasWrongDimension)
{
	if (new_data.size() != n_*m_)
	{
		Exception::MatrixHasWrongDimension e;
		throw(e);
	}
	else
		data_ = new_data;
}


///---------------------------------------


template <class valuetype, class mtraits>
int Matrix<valuetype, mtraits>::Nrows() const
{
	return n_;
}
	

template <class valuetype, class mtraits>
int Matrix<valuetype, mtraits>::Ncols() const
{
	return m_;
}
	
	
template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::setRow(size_t id, valuetype value)
{
	size_t cols=getColumnCount();
	for(size_t i=1; i<=cols;i++)
	{
		operator()(id,i)=value;
	}	
}
	
template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::setCol(size_t id, valuetype value)
{
	size_t rows=getRowCount();
	for(size_t i=1; i<=rows;i++)
	{
		operator()(i,id)=value;
	}
}
	

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::operator=(Matrix<valuetype, mtraits>& m)
{
	size_t rows=m.getRowCount();
	size_t cols=m.getColumnCount();
	resize(rows,cols);
	for(size_t i=1; i<=rows;i++)
	{
		for(size_t j=1; j<=cols;j++)
		{
			operator()(i,j)=m(i,j);
		}
	}
}
	

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::operator=(valuetype v)
{
	size_t rows=getRowCount();
	size_t cols=getColumnCount();
	for(size_t i=1; i<=rows;i++)
	{
		for(size_t j=1; j<=cols;j++)
		{
			operator()(i,j)=v;
		}
	}
}


template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::operator-=(valuetype v)
{
	size_t rows=getRowCount();
	size_t cols=getColumnCount();
	for(size_t i=1; i<=rows;i++)
	{
		for(size_t j=1; j<=cols;j++)
		{
			operator()(i,j)-=v;
		}
	}
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::operator+=(valuetype v)
{
	size_t rows=getRowCount();
	size_t cols=getColumnCount();
	for(size_t i=1; i<=rows;i++)
	{
		for(size_t j=1; j<=cols;j++)
		{
			operator()(i,j)+=v;
		}
	}
}


template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::operator*=(Matrix<valuetype, mtraits>& B)
{
	if (getColumnCount() != B.getRowCount())
	{
		Exception::MatrixHasWrongDimension e;
		throw (e);
	}
	
	Matrix<valuetype, mtraits> result(getRowCount(), B.getColumnCount(), (valuetype)0);
	
#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using multiply_blas" << std::endl;
#endif
	multiply_blas(result, B);	
#else
#ifdef DEBUG
	std::cout << "Info: using multiply_native" << std::endl;
#endif
	multiply_native(result, B);
#endif
	*this = result;
}
	
	
template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::setToIdentity(size_t no_rows)
{
	resize(no_rows,no_rows);
	for(size_t i=1; i<=no_rows;i++)
	{
		for(size_t j=1;j<=no_rows;j++)
		{
			if(i==j) operator()(i,j)=1;
			else operator()(i,j)=0;
		}
	}
}


template <class valuetype, class mtraits>
valuetype Matrix<valuetype, mtraits>::rowSum(size_t row)
{
	size_t cols=getColumnCount();
	valuetype sum=0;
	for(size_t i=1; i<=cols;i++)
	{
		sum += operator()(row,i);
	}
	return sum;	
}


template <class valuetype, class mtraits>
valuetype Matrix<valuetype, mtraits>::colSum(size_t column)
{
	size_t rows=getRowCount();
	valuetype sum=0;
	for(size_t i=1; i<=rows;i++)
	{
		sum += operator()(i,column);
	}
	return sum;	
}


template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::addColumn(Vector<valuetype>& column)
{
	if(column.getSize() != getRowCount())
	{
		String name = "addColumn error";
		String mess = "no of elements of the given vector must be equal to number of rows of the matrix";
		throw BALL::Exception::GeneralException(__FILE__,__LINE__,name,mess);		
	}
	Matrix<valuetype, mtraits> previous_columns = *this;
	
	resize(getRowCount(),getColumnCount()+1);
	
	size_t rows=getRowCount();
	size_t cols=getColumnCount();
	for(size_t i=1; i<=rows;i++)
	{
		for(size_t j=1; j<rows;j++)
		{
			operator()(i,j) = previous_columns(i,j);
		}
		operator()(i,cols) = column(i);
	}
}
	
template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::copyVectorToRow(Vector<valuetype>& vector, size_t row)
{
	size_t cols = getColumnCount();
	for(size_t i=1; i<=cols;i++)
	{
		operator()(row,i) = vector(i);
	}	
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::copyRowToVector(Vector<valuetype>& vector, size_t row)
{
	size_t cols = getColumnCount();
	for(size_t i=1; i<=cols;i++)
	{
		vector(i) = operator()(row,i);
	}	
}


///---------------------------------------


template <class valuetype, class mtraits>
size_t Matrix<valuetype, mtraits>::getRowCount() const
{
	return n_;
}
	
template <class valuetype, class mtraits>
size_t Matrix<valuetype, mtraits>::getColumnCount() const
{
	return m_;
}

template <class valuetype, class mtraits>
size_t Matrix<valuetype, mtraits>::getSize() const
{
	return data_.size();
}

template <class valuetype, class mtraits>
bool Matrix<valuetype, mtraits>::isRowMajor() const
{
	return row_major_;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::setRowMajor(bool is_row_major)
{
	row_major_ = is_row_major;
}

template <class valuetype, class mtraits>
size_t Matrix<valuetype, mtraits>::convertIndicesToOffset(size_t i, size_t j) const
{
	// which storage order do we use?
	if (row_major_)
	{
		return (j-1) + m_*(i-1);
	}
	else
	{
		return (i-1) + n_*(j-1);
	}
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::convertOffsetToIndices(size_t offset, size_t& i, size_t& j) const
{
	if (row_major_)
	{
		i = offset / m_ + 1;
		j = offset % m_ + 1;
	}
	else
	{
		i = offset % n_ + 1;
		j = offset / n_ + 1;
	}
}

// *all* specialized matrices with other storage types than the standard type will
// need to re-define this method! here, we can assume StandardTraits so
// we can use memcpy if the storage type fits our needs to speed things up
template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::copyColumnToVector(Vector<valuetype>& vector, size_t to_exchange)
{
	if (to_exchange == 0 || to_exchange > m_)
	{
		std::cerr << "Matrix::copyColumnToVector(): index " << to_exchange << " out of bounds!" << std::endl;
		return;
	}

	if (vector.getSize() != n_)
	{
		std::cerr << "Matrix::copyColumnToVector(): expected vector of size " << n_
							<< ", got vector of size " << vector.getSize() << std::endl;
		return;
	}

	// we can do this only for column major matrices of course
	if (!row_major_)
	{
		memcpy(&(vector[0]), &(data_[convertIndicesToOffset(1, to_exchange)]), n_ * sizeof(valuetype));
	}
	else
	{
		for (size_t i=0; i<n_; i++)
		{
			vector[i] = data_[convertIndicesToOffset(i+1, to_exchange)];
		}
	}
}

// *all* specialized matrices with other storage types than the standard type will
// need to re-define this method! here, we can assume StandardTraits so
// we can use memcpy if the storage type fits our needs to speed things up
template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::copyVectorToColumn(Vector<valuetype>& vector, size_t to_exchange)
{
	if (to_exchange == 0 || to_exchange > m_)
	{
		std::cerr << "Matrix::copyVectorToColumn(): index " << to_exchange << " out of bounds!" << std::endl;
		return;
	}

	if (vector.getSize() != n_)
	{
		std::cerr << "Matrix::copyVectorToColumn(): expected vector of size " << n_
							<< ", got vector of size " << vector.getSize() << std::endl;
		return;
	}

	// we can do this only for column major matrices of course
	if (!row_major_)
	{
		memcpy(&(data_[convertIndicesToOffset(1, to_exchange)]), &(vector[0]), n_ * sizeof(valuetype));
	}
	else
	{
		for (size_t i=0; i<n_; i++)
		{
			data_[convertIndicesToOffset(i+1, to_exchange)] = vector[i];
		}
	}
}

template <class valuetype, class mtraits>
valuetype& Matrix<valuetype, mtraits>::operator() (size_t i, size_t j)
{
	// which storage order do we use?
	if (row_major_)
	{
		return data_[(j-1) + m_*(i-1)];
	}
	else
	{
		return data_[(i-1) + n_*(j-1)];
	}
}

template <class valuetype, class mtraits>
const valuetype& Matrix<valuetype, mtraits>::operator() (size_t i, size_t j) const
{
	// which storage order do we use?
	if (row_major_)
	{
		return data_[(j-1) + m_*(i-1)];
	}
	else
	{
		return data_[(i-1) + n_*(j-1)];
	}
}

template <class valuetype, class mtraits>
valuetype& Matrix<valuetype, mtraits>::operator [] (size_t position)
{
	return data_[position];
}

template <class valuetype, class mtraits>
const valuetype& Matrix<valuetype, mtraits>::operator [] (size_t position) const
{
	return data_[position];
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::resize(int n, int m)
{
	n_ = n;
	m_ = m;
	data_.resize(n*m);
}

template <class valuetype, class mtraits>
bool Matrix<valuetype, mtraits>::transpose(bool deep)
{
	if (!deep)
	{
		row_major_ = !row_major_;
	}
	else
	{
		/** This is based on:
		 * 		"MPI and OpenMP paradigms on cluster of SMP architectures: 
		 * 		 the vacancy tracking algorithm for multi-dimensional array transposition"
		 *  By Yun He and Chris Ding
		 */
		size_t ioffset_start;
		size_t ioffset_next  = -1;
		valuetype tmp;
		size_t ioffset;
		size_t j1=0,j2=0;
		size_t size = n_*m_;
		std::vector<bool> touched(size, false);
		for (size_t current_start=1; current_start<size; current_start++)
		{
			if (!touched[current_start])
			{
				ioffset_start = current_start;
				ioffset = ioffset_start;
				tmp = data_[ioffset_start];

				while (ioffset_next != ioffset_start)
				{
					std::swap(n_,m_);
					convertOffsetToIndices(ioffset,j1,j2);
					std::swap(n_,m_);

					ioffset_next = convertIndicesToOffset(j2,j1);
					if (ioffset != ioffset_next && ioffset_next != ioffset_start)
					{
						touched[ioffset] = true;
						data_[ioffset] = data_[ioffset_next];
						ioffset = ioffset_next;
					}
				};
				touched[ioffset] = true;
				data_[ioffset] = tmp;
			}
		}
	}

	std::swap(n_,m_);
	return true;
}

template <class valuetype, class mtraits>
Matrix<valuetype, mtraits> Matrix<valuetype, mtraits>::t() const
{
	Matrix<valuetype, mtraits> result(m_, n_, row_major_);
	
	// TODO: - rewrite!
	//			 - add an implementation using BLAS
	// this is obviously a pretty stupid implementation and does not care about, e.g., cache line
	// efficiency
	for (size_t i=1; i<=n_; i++)
	{
		for (size_t j=1; j<=m_; j++)
		{
			result(j,i) = (*this)(i,j);
		}
	}

	return result;
}

template <class valuetype, class mtraits>
bool Matrix<valuetype, mtraits>::isQuadratic() const
{
	return (m_ == n_);
}

template <class valuetype, class mtraits>
Matrix<valuetype, mtraits> Matrix<valuetype, mtraits>::operator + (const Matrix<valuetype, mtraits>& B) const
	throw(Exception::MatrixHasWrongDimension)
{
	if ( (getRowCount() != B.getRowCount()) || (getColumnCount() != B.getColumnCount()) )
	{
		Exception::MatrixHasWrongDimension e;
		throw (e);
	}

	Matrix<valuetype, mtraits> result(getRowCount(), getColumnCount());
#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using add_blas" << std::endl;
#endif
	add_blas(result, B);	
#else
#ifdef DEBUG
	std::cout << "Info: using add_native" << std::endl;
#endif
	add_native(result, B);
#endif

	return result;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::add_native(Matrix<valuetype, mtraits>& result, const Matrix<valuetype, mtraits>& B) const
{
	/** At least try to gain some speed... **/
	valuetype* result_ptr 			= &result[0];
	valuetype const* this_ptr   = &data_[0];
	valuetype const* b_ptr			= &B[0];

	bool B_row_major = B.isRowMajor();

	// we have to take care of possible shallow transposal
	if (row_major_ == B_row_major)
	{
		size_t size = data_.size();
		for (size_t i=0; i<size; i++)
		{
			*result_ptr = *this_ptr++ + *b_ptr++;
			result_ptr++;
		}

		// and set the correct storage mode
		result.setRowMajor(row_major_);
	}
	else
	{
		if (row_major_) // matrix B is in column order
		{
			// take one row at a time
			for (size_t i=0; i<n_; i++)
			{
				// advance to the next row
				b_ptr = &B[i];
				for (size_t j=0; j<m_; j++)
				{
					*result_ptr = *this_ptr++ + *b_ptr;
					b_ptr += n_;
					result_ptr++;
				}
			}
		}
		else // only our matrix is in column order
		{
			// take one row at a time
			for (size_t i=0; i<n_; i++)
			{
				// advance to the next row
				this_ptr = &data_[i];
				for (size_t j=0; j<m_; j++)
				{
					*result_ptr = *this_ptr + *b_ptr++;
					this_ptr += n_;
					result_ptr++;
				}
			}
		}
	}
}

template <class valuetype, class mtraits>
Matrix<valuetype, mtraits>& Matrix<valuetype, mtraits>::operator += (const Matrix<valuetype, mtraits>& B)
	throw(Exception::MatrixHasWrongDimension)
{
	if ( (getRowCount() != B.getRowCount()) || (getColumnCount() != B.getColumnCount()) )
	{
		Exception::MatrixHasWrongDimension e;
		throw (e);
	}

#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using add_inline_blas" << std::endl;
#endif
	add_inline_blas(B);	
#else
#ifdef DEBUG
	std::cout << "Info: using add_native" << std::endl;
#endif
	add_inline_native(B);
#endif
	
	return *this;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::add_inline_native(const Matrix<valuetype, mtraits>& B)
{
	/** At least try to gain some speed... **/
	valuetype* this_ptr   = &data_[0];
	valuetype const* b_ptr			= &B[0];

	bool B_row_major = B.isRowMajor();

	// we have to take care of possible shallow transposal
	if (row_major_ == B_row_major)
	{
		size_t size = data_.size();
		for (size_t i=0; i<size; i++)
		{
			*this_ptr = *this_ptr + *b_ptr++;
			this_ptr++;
		}
	}
	else
	{
		if (row_major_) // matrix B is in column order
		{
			// take one row at a time
			for (size_t i=0; i<n_; i++)
			{
				// advance to the next row
				b_ptr = &B[i];
				for (size_t j=0; j<m_; j++)
				{
					*this_ptr = *this_ptr + *b_ptr;
					b_ptr += n_;
					this_ptr++;
				}
			}
		}
		else // only our matrix is in column order
		{
			// take one row at a time
			for (size_t i=0; i<m_; i++)
			{
				// advance to the next row
				b_ptr = &B[i];
				for (size_t j=0; j<n_; j++)
				{
					*this_ptr = *this_ptr + *b_ptr;
					b_ptr += m_;
					this_ptr++;
				}
			}
		}
	}
}

template <class valuetype, class mtraits>
Matrix<valuetype, mtraits> Matrix<valuetype, mtraits>::operator - (const Matrix<valuetype, mtraits>& B) const
	throw(Exception::MatrixHasWrongDimension)
{
	if ( (getRowCount() != B.getRowCount()) || (getColumnCount() != B.getColumnCount()) )
	{
		Exception::MatrixHasWrongDimension e;
		throw (e);
	}

	Matrix<valuetype, mtraits> result(getRowCount(), getColumnCount());
#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using subtract_blas" << std::endl;
#endif
	subtract_blas(result, B);	
#else
#ifdef DEBUG
	std::cout << "Info: using subtract_native" << std::endl;
#endif
	subtract_native(result, B);
#endif

	return result;
}


template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::subtract_native(Matrix<valuetype, mtraits>& result, const Matrix<valuetype, mtraits>& B) const
{
	/** At least try to gain some speed... **/
	valuetype* result_ptr 			= &result[0];
	valuetype const* this_ptr   = &data_[0];
	valuetype const* b_ptr			= &B[0];

	bool B_row_major = B.isRowMajor();

	// we have to take care of possible shallow transposal
	if (row_major_ == B_row_major)
	{
		size_t size = data_.size();
		for (size_t i=0; i<size; i++)
		{
			*result_ptr = *this_ptr++ - *b_ptr++;
			result_ptr++;
		}

		// and set the correct storage mode
		result.setRowMajor(row_major_);
	}
	else
	{
		if (row_major_) // matrix B is in column order
		{
			// take one row at a time
			for (size_t i=0; i<n_; i++)
			{
				// advance to the next row
				b_ptr = &B[i];
				for (size_t j=0; j<m_; j++)
				{
					*result_ptr = *this_ptr++ - *b_ptr;
					b_ptr += n_;
					result_ptr++;
				}
			}
		}
		else // only our matrix is in column order
		{
			// take one row at a time
			for (size_t i=0; i<n_; i++)
			{
				// advance to the next row
				this_ptr = &data_[i];
				for (size_t j=0; j<m_; j++)
				{
					*result_ptr = *this_ptr - *b_ptr++;
					this_ptr += n_;
					result_ptr++;
				}
			}
		}
	}
}

template <class valuetype, class mtraits>
Matrix<valuetype, mtraits>& Matrix<valuetype, mtraits>::operator -= (const Matrix<valuetype, mtraits>& B)
	throw(Exception::MatrixHasWrongDimension)
{
	if ( (getRowCount() != B.getRowCount()) || (getColumnCount() != B.getColumnCount()) )
	{
		Exception::MatrixHasWrongDimension e;
		throw (e);
	}

#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using add_blas" << std::endl;
#endif
	subtract_inline_blas(B);	
#else
#ifdef DEBUG
	std::cout << "Info: using add_native" << std::endl;
#endif
	subtract_inline_native(B);
#endif

	return *this;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::subtract_inline_native(const Matrix<valuetype, mtraits>& B)
{
	/** At least try to gain some speed... **/
	valuetype* this_ptr   = &data_[0];
	valuetype const* b_ptr			= &B[0];

	bool B_row_major = B.isRowMajor();

	// we have to take care of possible shallow transposal
	if (row_major_ == B_row_major)
	{
		size_t size = data_.size();
		for (size_t i=0; i<size; i++)
		{
			*this_ptr = *this_ptr - *b_ptr++;
			this_ptr++;
		}
	}
	else
	{
		if (row_major_) // matrix B is in column order
		{
			// take one row at a time
			for (size_t i=0; i<n_; i++)
			{
				// advance to the next row
				b_ptr = &B[i];
				for (size_t j=0; j<m_; j++)
				{
					*this_ptr = *this_ptr - *b_ptr;
					b_ptr += n_;
					this_ptr++;
				}
			}
		}
		else // only our matrix is in column order
		{
			// take one row at a time
			for (size_t i=0; i<m_; i++)
			{
				// advance to the next row
				b_ptr = &B[i];
				for (size_t j=0; j<n_; j++)
				{
					*this_ptr = *this_ptr - *b_ptr;
					b_ptr += m_;
					this_ptr++;
				}
			}
		}
	}
}


template <class valuetype, class mtraits>
Matrix<valuetype, mtraits> Matrix<valuetype, mtraits>::operator* (const valuetype& a) const
	throw()
{
	Matrix<valuetype, mtraits> result(*this);

#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using multiply_blas" << std::endl;
#endif
	multiply_blas(result, a);	
#else
#ifdef DEBUG
	std::cout << "Info: using multiply_native" << std::endl;
#endif
	multiply_native(result, a);
#endif

	return result;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::multiply_native(Matrix<valuetype, mtraits>& result, const valuetype& a) const
{
	valuetype* v_ptr = const_cast<valuetype*>(&result[0]);

	for (size_t i=0; i<result.getSize(); i++)
		*v_ptr++ *= a;
}

template <class valuetype, class mtraits>
Matrix<valuetype, mtraits>& Matrix<valuetype, mtraits>::operator*= (const valuetype& a)
	throw()
{
#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using multiply_inline_blas" << std::endl;
#endif
	multiply_inline_blas(a);	
#else
#ifdef DEBUG
	std::cout << "Info: using multiply_inline_native" << std::endl;
#endif
	multiply_inline_native(a);
#endif

	return *this;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::multiply_inline_native(const valuetype& a)
{
	valuetype* v_ptr = &data_[0];
	size_t size = data_.size();

	for (size_t i=0; i<size; i++)
		*v_ptr++ *= a;
}

template <class valuetype, class mtraits>
Matrix<valuetype, mtraits> Matrix<valuetype, mtraits>::operator* (const Matrix<valuetype, mtraits>& B) const
	throw(Exception::MatrixHasWrongDimension)
{
	if (getColumnCount() != B.getRowCount())
	{
		Exception::MatrixHasWrongDimension e;
		throw (e);
	}

	Matrix<valuetype, mtraits> result(getRowCount(), B.getColumnCount(), (valuetype)0);
#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using multiply_blas" << std::endl;
#endif
	multiply_blas(result, B);	
#else
#ifdef DEBUG
	std::cout << "Info: using multiply_native" << std::endl;
#endif
	multiply_native(result, B);
#endif

	return result;
}

template <class valuetype, class mtraits>
void Matrix<valuetype, mtraits>::multiply_native(Matrix<valuetype, mtraits>& result, const Matrix<valuetype, mtraits>& B) const
{
	/** TODO: This function should definitely support more stable and efficient
	 * 				algorithms for multiplication than this trivial one... We need to
	 * 				choose between them using an enum.
	 */
	size_t B_n = B.getRowCount();
	size_t B_m = B.getColumnCount();
	bool B_row_major = B.isRowMajor();

	/** We use an inefficient O(n^3) algorithm that is not really stable... **/
	valuetype* 			 result_ptr = &result[0];
	valuetype const* this_ptr	  = &data_[0];
	valuetype const* b_ptr			= &B[0];
	valuetype const* this_l_ptr;
	valuetype const* b_l_ptr;

	if (row_major_ == B_row_major)
	{
		if (row_major_) // both matrices in row major
		{
			for (size_t i=0; i<n_; i++)
			{
				for (size_t j=0; j<B_m; j++)
				{
					this_l_ptr = this_ptr;
					b_l_ptr    = b_ptr;				
					for (size_t k=0; k<m_; k++)
					{
						*result_ptr += (*this_l_ptr++) * (*b_l_ptr);
						b_l_ptr    += B_m;
					}
					result_ptr++;
					b_ptr++;
				}
				this_ptr += m_;
				b_ptr     = &(B[0]);
			}
		}
		else // both matrices are column major
		{
			/* Our result will be stored in column major as well.
			 * We thus iterate over the rows of the result first, and thus in the
			 * inner loop we have to advance one row in this matrix and keep B
			 * at the same value (the corresponding column).
			 */
			for (size_t i=0; i<B_m; i++)
			{
				for (size_t j=0; j<n_; j++)
				{
					this_l_ptr = this_ptr;
					b_l_ptr    = b_ptr;				
					for (size_t k=0; k<m_; k++)
					{
						*result_ptr += (*this_l_ptr) * (*b_l_ptr++);
						this_l_ptr  += n_;
					}
					result_ptr++;
					this_ptr++;
				}
				this_ptr  = &(data_[0]);
				b_ptr    += B_n;
			}

			result.setRowMajor(false);
		}
	}
	else // both matrices have differing storage order
	{
		if (row_major_) // this matrix and the result are in row major, B is column major
		{
			for (size_t i=0; i<n_; i++)
			{
				for (size_t j=0; j<B_m; j++)
				{
					this_l_ptr = this_ptr;
					for (size_t k=0; k<m_; k++)
					{
						*result_ptr += (*this_l_ptr++) * (*b_ptr++);
					}
					result_ptr++;
				}
				this_ptr += m_;
				b_ptr     = &(B[0]);
			}
		}
		else // B and the result are in row major, this matrix is in column major
		{
			for (size_t i=0; i<n_; i++)
			{
				for (size_t j=0; j<B_m; j++)
				{
					this_l_ptr = this_ptr;
					b_l_ptr    = b_ptr;				
					for (size_t k=0; k<m_; k++)
					{
						*result_ptr += (*this_l_ptr) * (*b_l_ptr);
						this_l_ptr += n_;
						b_l_ptr    += B_m;
					}
					result_ptr++;
					b_ptr++;
				}
				this_ptr++;
				b_ptr     = &(B[0]);
			}
		}
	}
}


template <>
void Matrix<float, StandardTraits>::add_blas(Matrix<float, StandardTraits>& result, const Matrix<float, StandardTraits>& B) const;

template <>
void Matrix<double, StandardTraits>::add_blas(Matrix<double, StandardTraits>& result, const Matrix<double, StandardTraits>& B) const;

template <> 
void Matrix<ComplexFloat, StandardTraits>::add_blas(Matrix<ComplexFloat, StandardTraits>& result, const Matrix<ComplexFloat, StandardTraits>& B) const;

template <>
void Matrix<ComplexDouble, StandardTraits>::add_blas(Matrix<ComplexDouble, StandardTraits>& result, const Matrix<ComplexDouble, StandardTraits>& B) const;

////////////////////////////////////////////////////////////

template <>
void Matrix<float, StandardTraits>::add_inline_blas(const Matrix<float, StandardTraits>& B);

template <>
void Matrix<double, StandardTraits>::add_inline_blas(const Matrix<double, StandardTraits>& B);

template <>
void Matrix<ComplexFloat, StandardTraits>::add_inline_blas(const Matrix<ComplexFloat, StandardTraits>& B);

template <>
void Matrix<ComplexDouble, StandardTraits>::add_inline_blas(const Matrix<ComplexDouble, StandardTraits>& B);

////////////////////////////////////////////////////////////

template <>
void Matrix<float, StandardTraits>::subtract_blas(Matrix<float, StandardTraits>& result, const Matrix<float, StandardTraits>& B) const;

template <>
void Matrix<double, StandardTraits>::subtract_blas(Matrix<double, StandardTraits>& result, const Matrix<double, StandardTraits>& B) const;

template <>
void Matrix<ComplexFloat, StandardTraits>::subtract_blas(Matrix<ComplexFloat, StandardTraits>& result, const Matrix<ComplexFloat, StandardTraits>& B) const;

template <>
void Matrix<ComplexDouble, StandardTraits>::subtract_blas(Matrix<ComplexDouble, StandardTraits>& result, const Matrix<ComplexDouble, StandardTraits>& B) const;

////////////////////////////////////////////////////////////

template <>
void Matrix<float, StandardTraits>::subtract_inline_blas(const Matrix<float, StandardTraits>& B);

template <>
void Matrix<double, StandardTraits>::subtract_inline_blas(const Matrix<double, StandardTraits>& B) ;

template <>
void Matrix<ComplexFloat, StandardTraits>::subtract_inline_blas(const Matrix<ComplexFloat, StandardTraits>& B);

template <>
void Matrix<ComplexDouble, StandardTraits>::subtract_inline_blas(const Matrix<ComplexDouble, StandardTraits>& B);

////////////////////////////////////////////////////////////

template <>
void Matrix<float, StandardTraits>::multiply_blas(Matrix<float, StandardTraits>& result, const float& a) const;

template <>
void Matrix<double, StandardTraits>::multiply_blas(Matrix<double, StandardTraits>& result, const double& a) const;

/** TODO: multiplication by float instead of ComplexFloat **/
template <>
void Matrix<ComplexFloat, StandardTraits>::multiply_blas(Matrix<ComplexFloat, StandardTraits>& result, const ComplexFloat& a) const;

template <>
void Matrix<ComplexDouble, StandardTraits>::multiply_blas(Matrix<ComplexDouble, StandardTraits>& result, const ComplexDouble& a) const;

////////////////////////////////////////////////////////////

template <>
void Matrix<float, StandardTraits>::multiply_inline_blas(const float& a);

template <>
void Matrix<double, StandardTraits>::multiply_inline_blas(const double& a);

template <>
void Matrix<ComplexFloat, StandardTraits>::multiply_inline_blas(const ComplexFloat& a);

template <>
void Matrix<ComplexDouble, StandardTraits>::multiply_inline_blas(const ComplexDouble& a);

////////////////////////////////////////////////////////////

template <>
void Matrix<float, StandardTraits>::multiply_blas(Matrix<float, StandardTraits>& result, const Matrix<float, StandardTraits>& B) const;

template <>
void Matrix<double, StandardTraits>::multiply_blas(Matrix<double, StandardTraits>& result, const Matrix<double, StandardTraits>& B) const;

template <>
void Matrix<ComplexFloat, StandardTraits>::multiply_blas(Matrix<ComplexFloat, StandardTraits>& result, const Matrix<ComplexFloat, StandardTraits>& B) const;

template <>
void Matrix<ComplexDouble, StandardTraits>::multiply_blas(Matrix<ComplexDouble, StandardTraits>& result, const Matrix<ComplexDouble, StandardTraits>& B) const;

template <class valuetype, class mtraits>
Vector<valuetype> Matrix<valuetype, mtraits>::operator* (const Vector<valuetype>& X) const
	throw(Exception::VectorHasWrongDimension)
{
	if ((uint)getColumnCount() != X.getSize())
	{
		Exception::VectorHasWrongDimension e;
		throw (e);
	}

	Vector<valuetype> result(getRowCount());

#ifdef BALL_HAS_BLAS
#ifdef DEBUG
	std::cout << "Info: using multiply_blas" << std::endl;
#endif
	X.multiply_blas(result, *this);	
#else
#ifdef DEBUG
	std::cout << "Info: using multiply_native" << std::endl;
#endif
	X.multiply_native(result, *this);
#endif

	return result;
}

}
#endif
