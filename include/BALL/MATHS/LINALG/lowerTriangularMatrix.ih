#ifndef BALL_LINALG_LOWERTRIANGULARMATRIX_IH
#define BALL_LINALG_LOWERTRIANGULARMATRIX_IH

namespace BALL {

	typedef std::complex<float>  ComplexFloat;
	typedef std::complex<double> ComplexDouble;

	/** @ingroup TriangularMatrices
	 *
	 *  Partial specialization of the Matrix-class for lower triangular matrices. 
   *
	 *  Please note that these matrices are necessarily quadratic, i.e., n==m.
	 *
   *  We store matrices in packed storage format. For example, a 4 x 4 - matrix
	 *
	 *   / a_11  0    0    0   \
	 *  |  a_21 a_22  0    0    |
	 *  |  a_31 a_32 a_33  0    |
	 *   \ a_41 a_42 a_43 a_44 /
	 * 
	 *  with row_major_ == true is stored as
	 * 
	 *  (a_11, a_21, a_22, a_31, a_32, a_33, a_41, a_42, a_43, a_44)
	 * 
	 *  i.e., element a_ij, 1<=i,j<=n, is stored at position (j-1) + i*(i-1)/2
	 * 
	 *  and with row_major_ == false as
	 * 
	 *  (a_11, a_21, a_31, a_41, a_22, a_32, a_42, a_33, a_43, a_44)
	 * 
	 *  i.e., element a_ij, 1<=i,j<=n, is stored at position (i-1) + (2n-j)(j-1)/2
	 * 
	 *   A particular difficulty arises in defining random access operators ([] 
	 *   and ()) that return references to matrix entries, if an upper triangular
	 *   element is requested, i.e. one of the elements that are optimized away in 
	 *   our storage format. BALL solves this problem by returning a reference to the 
   *   member variable zero_. The value of zero_ is never used and hence, 
	 *   non-zero assignments to elements in the upper triangle are ignored.
	 */
	template <class valuetype>
	class Matrix<valuetype, LowerTriangularTraits>
	{
		/**
		*/
		typedef valuetype ValueType;

		/**
		*/
		typedef valuetype* PointerType;

		public:

			/**
			 *  Default constructor, creating a lower triangular matrix of 
			 *  size 0x0 in row_major format.
			 */
			Matrix();

			/** 
			 *  Explicit constructor of a lower triangular matrix of size n x n.
			 *  With the flag row_major, the storage order of the matrix can
			 *  be set to either row_major (default) or column major.
			 */
			Matrix(size_t n, bool row_major = true);

			/** 
			 *  Explicit constructor of a lower triangular matrix of size n x n.
			 *  With the flag row_major, the storage order of the matrix can
			 *  be set to either row_major (default) or column major.
			 *  initial_value can be used to initialize all values of the matrix.
			 */
			Matrix(size_t n, const valuetype& initial_value, bool row_major = true);

			/**
			 *  Copy constructor.
			 */
			Matrix(const Matrix& m);
			
			/**
			 *  Destructor.
			 */
			virtual ~Matrix();
			
			/** Clear method.
			 *  Puts the matrix into the same state as a default constructed one.
			 */
			virtual void clear();

			/** 
			 * Output operator, in-class version.
			 */
		  std::ostream& operator>> (std::ostream& stream) const;

			/**
			 * Input operator, in-class version.
			 */
			std::istream& operator<< (std::istream& stream);

			/** Convenient access to the matrix elements.
			 *  To be consistent with mathematical usage, the indices
			 *  start at 1, not at 0 as would be common for an array.
			 *
			 *  Note: if access to an element in the upper triangle is
			 *        requested, we return a reference to the member 
			 *        variable zero_. Changing the value of this variable 
			 *        will have no effect and hence, writes into
			 *				the upper triangle of this matrix will be ignored.
			 */
			valuetype& operator () (size_t i, size_t j);

			/** Convenient access to the matrix elements.
			 *  To be consistent with mathematical usage, the indices
			 *  start at 1, not at 0 as would be common for an array.
			 *
			 *  Note: if access to an element in the upper triangle is
			 *        requested, we return a reference to the member 
			 *        variable zero_. Changing the value of this variable 
			 *        will have no effect and hence, writes into
			 *				the upper triangle of this matrix will be ignored.
			 */
			const valuetype& operator () (size_t i, size_t j) const;

			valuetype& operator [] (size_t position);
			const valuetype& operator [] (size_t position) const;

			/** Assignment operator
			 *  
			 */
			Matrix& operator = (const Matrix& B);

			/** Checks for equality.
			 *  If two matrices differ only by their storage order, but represent
			 *  the same matrix, they are considered equal.
			 */
			template <class mtraits>
			bool operator == (const Matrix<valuetype, mtraits>& B) const;

			/** Checks for inequality.
			 *  If two matrices differ only by their storage order, but represent
			 *  the same matrix, they are considered equal.
			 */
			template <class mtraits>
			bool operator != (const Matrix<valuetype, mtraits>& B) const;
			
			/** Adds the matrix B on this matrix.
			 *  @throw Exception::MatrixHasWrongDimension If the dimensions 
			 *         of both matrices do not match			 
			 */
			inline Matrix& operator+= (const Matrix& B);
			
			/** Subtracts the matrix B from this matrix.
			 *  @throw Exception::MatrixHasWrongDimension If the dimensions 
			 *         of both matrices do not match			 
			 */
			inline Matrix& operator-= (const Matrix& B);
			
			/** Returns the sum of this matrix and the matrix B.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 *  @throw Exception::MatrixHasWrongDimension If the dimensions 
			 *         of both matrices do not match			 
			 */
			inline Matrix operator+ (const Matrix& B) const;

			/** Returns the difference of this matrix and the matrix B.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 *  @throw Exception::MatrixHasWrongDimension If the dimensions 
			 *         of both matrices do not match			 
			 */
			inline Matrix operator- (const Matrix& B) const;

			/** Scalar multiplication
			 *  Returns a matrix containing the entries of this matrix
			 *  multiplied with the factor a. The storage order of the new
			 *  matrix is the same as that of this matrix.
			 */
			inline Matrix operator* (const valuetype& a) const;

			/** Multiplies the entries of this matrix by the factor a.
			 */
			inline Matrix& operator*= (const valuetype& a);

			/** Returns the product of this matrix and the matrix B.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 *  @throw Exception::MatrixHasWrongDimension If the dimensions 
			 *         of both matrices do not match			 
			 */
	//		inline Matrix operator* (const Matrix& B) const;


			/** Returns a vector containing the entries of this matrix
			 *  right multiplied with the Vector X.
			 *  @throw Exception::VectorHasWrongDimension if the length of X
			 *         does not equal numColumns
			 */
	//		inline Vector<valuetype> operator* (const Vector<valuetype>& X) const;

			/** "fast" and unchecked version of matrix addition, native version.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 */
			void add_native(Matrix& result, const Matrix& B) const;

			/** "fast" and unchecked version of matrix addition, BLAS implementation version.
			 *  This can be significantly slower if at least one of the matrices is shallow
			 *  transposed.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 */
  	//		inline void add_blas(Matrix& result, const Matrix& B) const;

			/** "fast" and unchecked inline version of matrix addition, native version.
			 *  This can be significantly slower if at least one of the matrices is shallow
			 *  transposed.
			 *  The storage order of matrix will not be changed.
			 */
  			void add_inline_native(const Matrix& B);

			/** "fast" and unchecked version of matrix addition, BLAS implementation version.
			 *  This can be significantly slower if at least one of the matrices is shallow
			 *  transposed.
			 *  The storage order of the matrix will not be changed.
			 */
	//		inline void add_inline_blas(const Matrix& B);

			/** "fast" and unchecked version of matrix subtraction, native version.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 */
			void subtract_native(Matrix& result, const Matrix& B) const;

			/** "fast" and unchecked version of matrix subtraction, BLAS implementation version.
			 *  This can be significantly slower if at least one of the matrices is shallow
			 *  transposed.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 */
	//		inline void subtract_blas(Matrix& result, const Matrix& B) const;

			/** "fast" and unchecked inline version of matrix subtraction, native version.
			 *  This can be significantly slower if at least one of the matrices is shallow
			 *  transposed.
			 *  The storage order of matrix will not be changed.
			 */
			void subtract_inline_native(const Matrix& B);

			/** "fast" and unchecked version of matrix subtraction, BLAS implementation version.
			 *  This can be significantly slower if at least one of the matrices is shallow
			 *  transposed.
			 *  The storage order of the matrix will not be changed.
			 */
	//		inline void subtract_inline_blas(const Matrix& B);

			/** "fast" and unchecked version of multiplication with a scalar, native implementation.
			 *  The storage order of the result equals the storage order of this matrix.
			 */
			void multiply_native(Matrix& result, const valuetype& a) const;

			/** "fast" and unchecked version of multiplication with a scalar, BLAS implementation.
			 *  The storage order of the result equals the storage order of this matrix.
			 */
			inline void multiply_blas(Matrix& result, const valuetype& a) const;

			/** "fast" and unchecked version of inline multiplication with a scalar, 
			 *  native implementation. The storage order remains unchanged.
			 */
			void multiply_inline_native(const valuetype& a);

			/** "fast" and unchecked version of inline multiplication with a scalar, BLAS implementation 
			 *  native implementation. The storage order remains unchanged.
			 */
			inline void multiply_inline_blas(const valuetype& a);

			/** "fast" and unchecked version of matrix multiplication, native version.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 */
	//		void multiply_native(Matrix& result, const Matrix& B) const;

			/** "fast" and unchecked version of matrix multiplication, BLAS version.
			 *  The storage order of the result depends on the storage orders of the input matrices.
			 *  If both inputs have the same storage order, the output will have the same as well.
			 *  If the inputs differ in their storage, the output will have the default storage order
			 *  (row major).
			 */
	//		inline void multiply_blas(Matrix& result, const Matrix& B) const;

			/**
			 *  element row iterator
			 *
			 */

	//		friend class ElementRowIteratorTraits<valuetype>;

			/** Random access iterator for b.
			*/
	//		typedef RandomAccessIterator<Matrix, ValueType, PointerType, ElementRowIteratorTraits<valuetype> > ElementRowIterator;
			
			/// Return a element row iterator pointing to the first element in the matrix
	//		ElementRowIterator beginElementRow()
	//		{
	//			return ElementRowIterator::begin(*this);
	//		}

			/// Return a past-the-end element row iterator
	//		ElementRowIterator endElementRow()
	//		{
	//			return ElementRowIterator::end(*this);
	//		}

			/// Constant random access iterator for elements
	//		typedef ConstRandomAccessIterator<Matrix, ValueType, PointerType, ElementRowIteratorTraits<valuetype> > ElementRowConstIterator;

			/// Return a constant element row iterator pointing to the first element in the matrix
	//		ElementRowConstIterator beginElementRow() const
	//		{
	//			return ElementRowConstIterator::begin(*this);
	//		}

			/// Return a constant past-the-end element row iterator.
	//		ElementRowConstIterator endElementRow() const
	//		{
	//			return ElementRowConstIterator::end(*this);
	//		}
		
			/// Reverse random access iterator for row elements.
	//		typedef ReverseIterator<Matrix, ValueType, PointerType, ElementRowIteratorTraits<valuetype> >	ElementRowReverseIterator;

			/// Return a reverse row elements iterator pointing to the first element.
	//		ElementRowReverseIterator rbeginElementRow()
	//		{
	//			return ElementRowReverseIterator::begin(*this);
	//		}

			/// Return a past-the-end element row iterator for reverse traversal.
	//		ElementRowReverseIterator rendElementRow()
	//		{
	//			return ElementRowReverseIterator::end(*this);
	//		}

			/// Constant reverse random access iterator for row elements.
	//		typedef ConstReverseIterator<Matrix, ValueType, PointerType, ElementRowIteratorTraits<valuetype> > ElementRowConstReverseIterator;

			/// Return a constant reverse element row iterator pointing to the first element
	//		ElementRowConstReverseIterator rbeginElementRow() const
	//		{
	//			return ElementRowConstReverseIterator::begin(*this);
	//		}

			/// Return a constant past-the-end element row iterator for reverse traversal
	//		ElementRowConstReverseIterator rendElementRow() const
	//		{
	//			return ElementRowConstReverseIterator::end(*this);
	//		}



			/**
			 *  element column iterator
			 *
			 */

	//		friend class ElementColumnIteratorTraits<valuetype>;

			/** Random access iterator for b.
			*/
	//		typedef RandomAccessIterator<Matrix, ValueType, PointerType, ElementColumnIteratorTraits<valuetype> > ElementColumnIterator;
			
			/// Return a element column iterator pointing to the first element in the matrix
	//		ElementColumnIterator beginElementColumn()
	//		{
	//			return ElementColumnIterator::begin(*this);
	//		}

			/// Return a past-the-end element column iterator
	//		ElementColumnIterator endElementColumn()
	//		{
	//			return ElementColumnIterator::end(*this);
	//		}

			/// Constant random access iterator for elements
	//		typedef ConstRandomAccessIterator<Matrix, ValueType, PointerType, ElementColumnIteratorTraits<valuetype> > ElementColumnConstIterator;

			/// Return a constant element column iterator pointing to the first element in the matrix
	//		ElementColumnConstIterator beginElementColumn() const
	//		{
	//			return ElementColumnConstIterator::begin(*this);
	//		}

			/// Return a constant past-the-end element column iterator.
	//		ElementColumnConstIterator endElementColumn() const
	//		{
	//			return ElementColumnConstIterator::end(*this);
	//		}
		
			/// Reverse random access iterator for column elements.
	//		typedef ReverseIterator<Matrix, ValueType, PointerType, ElementColumnIteratorTraits<valuetype> >	ElementColumnReverseIterator;

			/// Return a reverse row elements iterator pointing to the first element.
	//		ElementColumnReverseIterator rbeginElementColumn()
	//		{
	//			return ElementColumnReverseIterator::begin(*this);
	//		}

			/// Return a past-the-end element column iterator for reverse traversal.
	//		ElementColumnReverseIterator rendElementColumn()
	//		{
	//			return ElementColumnReverseIterator::end(*this);
	//		}

			/// Constant reverse random access iterator for column elements.
	//		typedef ConstReverseIterator<Matrix, ValueType, PointerType, ElementColumnIteratorTraits<valuetype> > ElementColumnConstReverseIterator;

			/// Return a constant reverse element column iterator pointing to the first element
	//		ElementColumnConstReverseIterator rbeginElementColumn() const
	//		{
	//			return ElementColumnConstReverseIterator::begin(*this);
	//		}

			/// Return a constant past-the-end element column iterator for reverse traversal
	//		ElementColumnConstReverseIterator rendElementColumn() const
	//		{
	//			return ElementColumnConstReverseIterator::end(*this);
	//		}



			/**
			 *  row iterator
			 *
			 */

	//		friend class RowIteratorTraits<valuetype>;

			/** Random access iterator for b.
			*/
	//		typedef RandomAccessIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, RowIteratorTraits<valuetype> > RowIterator;
			
			/// Return a row iterator pointing to the first element in the matrix
	//		RowIterator beginRow()
	//		{
	//			return RowIterator::begin(*this);
	//		}

			/// Return a past-the-end row iterator
	//		RowIterator endRow()
	//		{
	//			return RowIterator::end(*this);
	//		}

			/// Constant random access iterator for elements
	//		typedef ConstRandomAccessIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, RowIteratorTraits<valuetype> > RowConstIterator;

			/// Return a constant row iterator pointing to the first element in the matrix
	//		RowConstIterator beginRow() const
	//		{
	//			return RowConstIterator::begin(*this);
	//		}

			/// Return a constant past-the-end row iterator.
	//		RowConstIterator endRow() const
	//		{
	//			return RowConstIterator::end(*this);
	//		}
		
			/// Reverse random access iterator for row.
	//		typedef ReverseIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, RowIteratorTraits<valuetype> >	RowReverseIterator;

			/// Return a reverse row iterator pointing to the first element.
	//		RowReverseIterator rbeginRow()
	//		{
	//			return RowReverseIterator::begin(*this);
	//		}

			/// Return a past-the-end row iterator for reverse traversal.
	//		RowReverseIterator rendRow()
	//		{
	//			return RowReverseIterator::end(*this);
	//		}

			/// Constant reverse random access iterator for rows.
	//		typedef ConstReverseIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, RowIteratorTraits<valuetype> > RowConstReverseIterator;

			/// Return a constant reverse row iterator pointing to the first element
	//		RowConstReverseIterator rbeginRow() const
	//		{
	//			return RowConstReverseIterator::begin(*this);
	//		}

			/// Return a constant past-the-end row iterator for reverse traversal
	//		RowConstReverseIterator rendRow() const
	//		{
	//			return RowConstReverseIterator::end(*this);
	//		}



			/**
			 *  column iterator
			 *
			 */

	//		friend class ColumnIteratorTraits<valuetype>;

			/** Random access iterator for b.
			*/
	//		typedef RandomAccessIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, ColumnIteratorTraits<valuetype> > ColumnIterator;
			
			/// Return a row iterator pointing to the first element in the matrix
	//		ColumnIterator beginColumn()
	//		{
	//			return ColumnIterator::begin(*this);
	//		}

			/// Return a past-the-end row iterator
	//		ColumnIterator endColumn()
	//		{
	//			return ColumnIterator::end(*this);
	//		}

			/// Constant random access iterator for elements
	//		typedef ConstRandomAccessIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, ColumnIteratorTraits<valuetype> > ColumnConstIterator;

			/// Return a constant row iterator pointing to the first element in the matrix
	//		ColumnConstIterator beginColumn() const
	//		{
	//			return ColumnConstIterator::begin(*this);
	//		}

			/// Return a constant past-the-end row iterator.
	//		ColumnConstIterator endColumn() const
	//		{
	//			return ColumnConstIterator::end(*this);
	//		}
		
			/// Reverse random access iterator for row.
	//		typedef ReverseIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, ColumnIteratorTraits<valuetype> >	ColumnReverseIterator;

			/// Return a reverse row iterator pointing to the first element.
	//		ColumnReverseIterator rbeginColumn()
	//		{
	//			return ColumnReverseIterator::begin(*this);
	//		}

			/// Return a past-the-end row iterator for reverse traversal.
	//		ColumnReverseIterator rendColumn()
	//		{
	//			return ColumnReverseIterator::end(*this);
	//		}

			/// Constant reverse random access iterator for rows.
	//		typedef ConstReverseIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, ColumnIteratorTraits<valuetype> > ColumnConstReverseIterator;

			/// Return a constant reverse row iterator pointing to the first element
	//		ColumnConstReverseIterator rbeginColumn() const
	//		{
	//			return ColumnConstReverseIterator::begin(*this);
	//		}

			/// Return a constant past-the-end row iterator for reverse traversal
	//		ColumnConstReverseIterator rendColumn() const
	//		{
	//			return ColumnConstReverseIterator::end(*this);
	//		}




			/**
			 *  diagonal iterator
			 *
			 */

	//		friend class DiagonalIteratorTraits<valuetype>;

			/** Random access iterator for b.
			*/
//			typedef RandomAccessIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, DiagonalIteratorTraits<valuetype> > DiagonalIterator;
			
			/// Return a row iterator pointing to the first element in the matrix
//			DiagonalIterator beginDiagonal()
	//		{
	//			return DiagonalIterator::begin(*this);
	//		}

			/// Return a past-the-end row iterator
	//		DiagonalIterator endDiagonal()
	//		{
	//			return DiagonalIterator::end(*this);
	//		}

			/// Constant random access iterator for elements
	//		typedef ConstRandomAccessIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, DiagonalIteratorTraits<valuetype> > DiagonalConstIterator;

			/// Return a constant row iterator pointing to the first element in the matrix
	//		DiagonalConstIterator beginDiagonal() const
	//		{
	//			return DiagonalConstIterator::begin(*this);
	//		}

			/// Return a constant past-the-end row iterator.
	//		DiagonalConstIterator endDiagonal() const
	//		{
	//			return DiagonalConstIterator::end(*this);
	//		}
		
			/// Reverse random access iterator for row.
	//		typedef ReverseIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, DiagonalIteratorTraits<valuetype> >	DiagonalReverseIterator;

			/// Return a reverse row iterator pointing to the first element.
	//		DiagonalReverseIterator rbeginDiagonal()
	//		{
	//			return DiagonalReverseIterator::begin(*this);
	//		}

			/// Return a past-the-end row iterator for reverse traversal.
	//		DiagonalReverseIterator rendDiagonal()
	//		{
	//			return DiagonalReverseIterator::end(*this);
	//		}

			/// Constant reverse random access iterator for rows.
	//		typedef ConstReverseIterator<Matrix, Vector<valuetype>, Vector<valuetype>*, DiagonalIteratorTraits<valuetype> > DiagonalConstReverseIterator;

			/// Return a constant reverse row iterator pointing to the first element
	//		DiagonalConstReverseIterator rbeginDiagonal() const
	//		{
	//			return DiagonalConstReverseIterator::begin(*this);
	//		}

			/// Return a constant past-the-end row iterator for reverse traversal
//			DiagonalConstReverseIterator rendDiagonal() const
//			{
//				return DiagonalConstReverseIterator::end(*this);
//			}

			/** Return a transposed version of this matrix.
       *  Note that, for reasons of efficiency, the storage order of the resulting
			 *  matrix will be inverse to that of this matrix.
       */
			Matrix<valuetype, UpperTriangularTraits> t() const;
		
	//		valuetype trace() const;

			bool isQuadratic() const;

			/** Return a copy of our raw data vector.
       */
			std::vector<valuetype> getData() const;

			/** Set the raw data vector of this class to a copy of the input vector.
			 *  @throw Exception::MatrixHasWrongDimension if the size of new_vector
			 *         does not equal rowCount*columnCount
			 */
			void setData(const std::vector<valuetype>& new_data);

			inline int getRowCount() const;
			inline int getColumnCount() const;
			inline size_t getSize() const;
	//		void resize(int n, int m);

			bool isUpper() const;
			bool isRowMajor() const;
			void setRowMajor(bool is_row_major);

			/** Convert indices to offset into the array.
			 * 
			 *  NOTE: This function does /not/ check the validity of the input, i.e.
			 *        we neither ensure that the indices are 1<=j<=i<=n. The value we
			 *				return in this case is undefined and may well be out of bounds of
			 *				the data array!
			 */
			size_t convertIndicesToOffset(size_t i, size_t j) const;

			/** Convert offsets into the array into indices.
			 */
			void convertOffsetToIndices(size_t offset, 
																	size_t& i, size_t& j) const;

		protected:
			std::vector<valuetype> data_;
			
			bool row_major_; 

			size_t n_;
			size_t m_;

			LowerTriangularTraits traits_;

			// used to return references to upper triangle elements
			mutable valuetype zero_;
	};

}

#endif // BALL_KERNEL_LOWERTRIANGULARMATRIX_IH
