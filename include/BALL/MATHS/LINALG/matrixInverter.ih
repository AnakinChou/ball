#ifndef BALL_LINALG_MATRIXINVERTER_IH
#define BALL_LINALG_MATRIXINVERTER_IH

#ifndef BALL_LINALG_GLOBAL_H
# include <BALL/MATHS/LINALG/global.h>
#endif

#ifndef BALL_LINALG_EXCEPTION_H
# include <BALL/MATHS/LINALG/linalgException.h>
#endif

#ifndef BALL_LINALG_MATRIXTRAITS_H
# include <BALL/MATHS/LINALG/matrixTraits.h>
#endif

#ifdef BALL_HAS_BLAS
extern "C"
{
# include "cblas.h"
}
#endif

#ifdef BALL_HAS_LAPACK
extern "C"
{
# include "lapack.h"
}
#endif

#include <iostream>
#include <complex>

namespace BALL {

typedef std::complex<float>  ComplexFloat;
typedef std::complex<double> ComplexDouble;

/** MatrixInverter class.
 *  This class computes the inverse or pseudo inverse of a given matrix and stores the results.
 */
template <class valuetype, class mtraits>
class MatrixInverter
{
	public:

		/** Default constructor, creating an empty MatrixInverter.
		 */
		MatrixInverter();

		/** Explicit constructor, connecting this MatrixInverter to the given matrix.
		 */
		MatrixInverter(const Matrix<valuetype, mtraits>& matrix);

		/** Clear currently stored values and bind this inverter to the given matrix.
		 */
		inline bool setup(const Matrix<valuetype, mtraits>& matrix);

		/** Compute the inverse of the matrix we are bound to.
		 */
		bool computeInverse();

		/** Compute the Moore-Penrose Pseudo-Inverse of the matrix we are bound to.
		 */
		bool computePseudoInverse();

		/**
		 *  Returns the inverse matrix
		 */
		inline Matrix<valuetype, StandardTraits>& getInverse();

		/**
		 *  Returns the inverse matrix
		 */
		inline Matrix<valuetype, StandardTraits> const& getInverse() const;

		/**
		 *  Returns the pseudo inverse
		 */
		inline Matrix<valuetype, StandardTraits>& getPseudoInverse();

		/**
		 *  Returns the pseudo inverse
		 */
		inline const Matrix<valuetype, StandardTraits>& getPseudoInverse() const;

	protected:
		const Matrix<valuetype, mtraits>* matrix_;

		Matrix<valuetype, mtraits> inverse_;
		Matrix<valuetype, mtraits> pseudo_inverse_;
};

}

#endif
