#ifndef BALL_LINALG_MATRIXCONSTRUCTORS_IC
#define BALL_LINALG_MATRIXCONSTRUCTORS_IC

namespace BALL {

	template <>
	Matrix<float, StandardTraits>::Matrix(const Matrix<float, StandardTraits>& m);

	template <>
	Matrix<double, StandardTraits>::Matrix(const Matrix<double, StandardTraits>& m);

	template <class valuetype, class mtraits>
	Matrix<valuetype, mtraits>::Matrix()
		: data_(0),
			row_major_(true),
			n_(0),
			m_(0)
	{
	}
	
	template <class valuetype, class mtraits>
	Matrix<valuetype, mtraits>::Matrix(size_t n, size_t m, bool row_major)
		: data_(n*m),
			row_major_(row_major),
			n_(n),
			m_(m) 
	{
	}

	template <class valuetype, class mtraits>
	Matrix<valuetype, mtraits>::Matrix(size_t n, size_t m, const valuetype& initial_value, bool row_major)
		: data_(n*m, initial_value),
			row_major_(row_major),
			n_(n),
			m_(m) 
	{
	}
	
	// TODO: use cblas_xcopy if HAS_BLAS && USE_BLAS
	template <class valuetype, class mtraits>
	Matrix<valuetype, mtraits>::Matrix(const Matrix<valuetype, mtraits>& m)
		: data_(m.n_*m.m_),
			row_major_(m.row_major_),
			n_(m.n_),
			m_(m.m_)
	{
		valuetype* 			 this_ptr   = &data_[0];
		valuetype const* m_ptr			= &m[0];

		for (size_t i=0; i<data_.size(); i++)
			*this_ptr++ = *m_ptr++;
	}	

	template <class valuetype, class mtraits>
	Matrix<valuetype, mtraits>::~Matrix()
	{
	}

	template <>
	Matrix<float, StandardTraits>& Matrix<float, StandardTraits>::operator = (const Matrix<float, StandardTraits>& m) ;

	template <>
	Matrix<double, StandardTraits>& Matrix<double, StandardTraits>::operator = (const Matrix<double, StandardTraits>& m) ;

	// TODO: use cblas_xcopy if HAS_BLAS && USE_BLAS
	template <class valuetype, class mtraits>
	Matrix<valuetype, mtraits>& Matrix<valuetype, mtraits>::operator = (const Matrix<valuetype, mtraits>& m)
	{
	  data_ = m.data_;
	  row_major_ = m.row_major_;
	  n_ = m.n_;
	  m_ = m.m_;
	  return *this;
	}
		
	template <class valuetype, class mtraits>
	bool Matrix<valuetype, mtraits>::operator == (const Matrix<valuetype, mtraits>& B) const
	{
		if (&B == this)
			return true;

		if ( (n_ != B.n_) || (m_ != B.m_) )
			return false;

		valuetype const*	this_ptr = &(data_[0]);
		valuetype const* 	b_ptr    = &(B[0]);
		bool equals = true;

		if (row_major_ == B.row_major_) // this is the easy case...
		{
			for (size_t i=0; i<data_.size(); i++)
			{
				if (*this_ptr++ != *b_ptr++)
				{
					equals = false;
					break;
				}
			}
		}
		else  // two different storage formats
		{
			if (row_major_) // b is column major
			{
				// take one row at a time
				for (size_t i=0; i<n_; i++)
				{
					// advance to the next row
					b_ptr = &B[i];
					for (size_t j=0; j<m_; j++)
					{
						if (*this_ptr++ != *b_ptr)
						{
							equals = false;
							break;
						}
						b_ptr += n_;
					}
				}
			}
			else // this matrix is in column order
			{
				// take one row at a time
				for (size_t i=0; i<n_; i++)
				{
					// advance to the next row
					this_ptr = &data_[i];
					for (size_t j=0; j<m_; j++)
					{
						if (*this_ptr != *b_ptr++)
						{
							equals = false;
							break;
						}
						this_ptr += n_;
					}
				}
			}
		}

		return equals;
	}

	template <class valuetype, class mtraits>
	bool Matrix<valuetype, mtraits>::operator != (const Matrix<valuetype, mtraits>& B) const
	{
		return !(*this == B);
	}
	
	// External definitions of the IO-Operators
	template <class valuetype, class mtraits>
	std::ostream& operator<< (std::ostream& stream, const Matrix<valuetype, mtraits>& m);

	template <class valuetype, class mtraits>
	std::istream& operator>> (std::istream& stream, Matrix<valuetype, mtraits>& m);
}
#endif
