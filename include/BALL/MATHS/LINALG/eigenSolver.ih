#ifndef BALL_LINALG_EIGENSOLVER_IH
#define BALL_LINALG_EIGENSOLVER_IH

#ifndef BALL_LINALG_GLOBAL_H
# include <BALL/MATHS/LINALG/global.h>
#endif

#ifndef BALL_LINALG_EXCEPTION_H
# include <BALL/MATHS/LINALG/linalgException.h>
#endif

#ifndef BALL_LINALG_MATRIXTRAITS_H
# include <BALL/MATHS/LINALG/matrixTraits.h>
#endif

#ifdef BALL_HAS_BLAS
extern "C"
{
# include "cblas.h"
}
#endif

#ifdef BALL_HAS_LAPACK
extern "C"
{
# include "lapack.h"
}
#endif

#include <iostream>
#include <complex>

namespace BALL {

typedef std::complex<float>  ComplexFloat;
typedef std::complex<double> ComplexDouble;

template <class valuetype, class mtraits>
class EigenSolverTraits
{
	public:
		/** Type of the eigenvalues.
		 */
		typedef std::complex<valuetype> EigenValueType;

		/** Type of the eigenvectors.
		 */
		typedef std::complex<valuetype> EigenVectorType;
};

template <> template <class mtraits>
class EigenSolverTraits<ComplexFloat, mtraits>
{
	public:
		/** Type of the eigenvalues.
		 */
		typedef ComplexFloat EigenValueType;

		/** Type of the eigenvectors.
		 */
		typedef ComplexFloat EigenVectorType;
};

template <> template <class mtraits>
class EigenSolverTraits<ComplexDouble, mtraits>
{
	public:
		/** Type of the eigenvalues.
		 */
		typedef ComplexDouble EigenValueType;

		/** Type of the eigenvectors.
		 */
		typedef ComplexDouble EigenVectorType;
};

template <class valuetype>
class EigenSolverTraits<valuetype, SymmetricTraits>
{
	public:
		/** Type of the eigenvalues.
		 */
		typedef valuetype EigenValueType;

		/** Type of the eigenvectors.
		 */
		typedef valuetype EigenVectorType;
};

template <class valuetype, class mtraits>
class EigenSolver
{
	public:

		/** Type of the eigenvalues.
		 */
		typedef typename EigenSolverTraits<valuetype, mtraits>::EigenValueType EigenValueType;

		/** Type of the eigenvectors.
		 */
		typedef typename EigenSolverTraits<valuetype, mtraits>::EigenVectorType EigenVectorType;

		/**
		 *  Default constructor, creating an empty eigenproblem solver.
		 */
		EigenSolver();

		/**
		 *  Explicit constructor, connecting this eigenproblem solver to the given matrix.
		 */
		EigenSolver(const Matrix<valuetype, mtraits>& matrix);

		/**
		 *  Clear currently stored values and bind this solver to the given matrix.
		 */
		inline bool setup(const Matrix<valuetype, mtraits>& matrix);

		/** Compute the eigenvalues and the right eigenvectors of the matrix we are bound to.
		 *	For a general matrix, the eigenvalues are necessarily stored as
		 *	a vector of complex values. For a symmetric matrix, a vector of
		 *	real values suffices.
		 *  NOTE: for reasons of efficiency and compatibility with LAPACK, the resulting
		 *  eigenvector matrix is always stored in column major format!
		 *  @return true if the computation terminated successfully
		 *  @return false otherwise
		 */
		inline bool solveRightEigenProblem()
			throw(Exception::OutOfMemory, Exception::MatrixNotQuadratic, Exception::Uninitialized);
 
		/** Compute the eigenvalues and the right eigenvectors of the matrix we are bound to,
		 *	native implementation.
		 *	For a general matrix, the eigenvalues are necessarily stored as
		 *	a vector of complex values. For a symmetric matrix, a vector of
		 *	real values suffices.
		 *	@return true if the computation terminated successfully
		 *	@return false otherwise
		 */
		inline bool solveRightEigenProblem_native();

		/** Compute the eigenvalues and the right eigenvectors of the matrix we are bound to
		 *	using LAPACK.
		 *	For a general matrix, the eigenvalues are necessarily stored as
		 *	a vector of complex values. For a symmetric matrix, a vector of
		 *	real values suffices.
		 *	@return true if the computation terminated successfully
		 *	@return false otherwise
		 */
		bool solveRightEigenProblem_lapack() throw (Exception::OutOfMemory);

		/** Sort the eigenvalues and their corresponding eigenvectors.
		 */
		void sort();

		/**
		 *  Returns the matrix of right eigenvectors.
		 */
		inline Matrix<EigenVectorType, StandardTraits>& getRightEigenvectors();

		/**
		 *  Returns the matrix of right eigenvectors.
		 */
		inline const Matrix<EigenVectorType, StandardTraits>& getRightEigenvectors() const;

		/**
		 *  Returns the vectors of right eigenvalues.
		 */
		inline Vector<EigenValueType>& getRightEigenvalues();

		/**
		 *  Returns the vectors of right eigenvalues.
		 */
		inline const Vector<EigenValueType>& getRightEigenvalues() const;

	protected:
		/** This nested class is needed for the sorting of eigenvalues.
		 */
		class EigenValueComparator_
		{
			public:
			  /** returns true, if a is considered sBALLer than b 
				 *  ("considered" because of the non-total ordering on
				 *  complex numbers)
				 **/
				bool operator () (const std::pair<EigenValueType, Index>& a, 
												  const std::pair<EigenValueType, Index>& b) const;

		};

		const Matrix<valuetype, mtraits>* matrix_;

		/**
		 *  In the non-specialized version, we need for complex eigenvectors and eigenvalues
		 *  for full generality. Specialized versions for symmetric real matrices will contain
		 *  real eigenvalues and vectors only. 
		*/
		Matrix<EigenVectorType, StandardTraits> right_eigenvectors_;
		Vector<EigenValueType> right_eigenvalues_;
};

}
#endif
