#ifndef BALL_LINALG_SVDSOLVER_IH
#define BALL_LINALG_SVDSOLVER_IH

#ifndef BALL_LINALG_GLOBAL_H
# include <BALL/MATHS/LINALG/global.h>
#endif

#ifndef BALL_LINALG_CONFIG_H
# include <BALL/MATHS/LINALG/config.h>
#endif

#ifndef BALL_LINALG_EXCEPTION_H
# include <BALL/MATHS/LINALG/linalgException.h>
#endif

#ifndef BALL_LINALG_MATRIXTRAITS_H
# include <BALL/MATHS/LINALG/matrixTraits.h>
#endif

#ifdef HAS_BLAS
extern "C"
{
# include "cblas.h"
}
#endif

#ifdef HAS_LAPACK
extern "C"
{
# include "lapack.h"
}
#endif

#include <iostream>
#include <complex>

namespace BALL {

typedef std::complex<float>  ComplexFloat;
typedef std::complex<double> ComplexDouble;

template <class valuetype, class mtraits>
class SVDSolverTraits
{
	public:
		/** Type of the singular values.
		 */
		typedef valuetype SingularValueType;

		/** Type of the singular vectors.
		 */
		typedef valuetype SingularVectorType;
};

template <> template <class mtraits>
class SVDSolverTraits<ComplexFloat, mtraits>
{
	public:
		/** Type of the singular values.
		 */
		typedef float SingularValueType;

		/** Type of the singular vectors.
		 */
		typedef ComplexFloat SingularVectorType;
};

template <> template <class mtraits>
class SVDSolverTraits<ComplexDouble, mtraits>
{
	public:
		/** Type of the singular values.
		 */
		typedef double SingularValueType;

		/** Type of the singular vectors.
		 */
		typedef ComplexDouble SingularVectorType;
};

/** SVDSolver class.
 *  This class computes the singular value decomposition of a given matrix and stores the results.
 */
template <class valuetype, class mtraits>
class SVDSolver
{
	public:
		/** Type of the singular values.
		 */
		typedef typename SVDSolverTraits<valuetype, mtraits>::SingularValueType SingularValueType;
		
		/** Type of the singular vectors.
		 */
		typedef typename SVDSolverTraits<valuetype, mtraits>::SingularVectorType SingularVectorType;			

		/** Default constructor, creating an empty SVD solver.
		 */
		SVDSolver();

		/** Explicit constructor, connecting this SVD solver to the given matrix.
		 */
		SVDSolver(const Matrix<valuetype, mtraits>& matrix);

		/** Clear currently stored values and bind this solver to the given matrix.
		 */
		inline bool setup(const Matrix<valuetype, mtraits>& matrix);

		/** Compute the singular value decomposition of the matrix we are bound to.
		 *  NOTE: for reasons of efficiency and compatibility with LAPACK, the resulting
		 *  singular vector matrix is always stored in column major format!
		 *  @return true if the computation terminated successfully
		 *  @return false otherwise
		 */
		inline bool computeSVD()
				throw(Exception::OutOfMemory, Exception::Uninitialized);

		/** Compute the singular value decomposition of the matrix we are bound to,
		 *  native implementation.
		 *  NOTE: for reasons of efficiency and compatibility with LAPACK, the resulting
		 *  singular vector matrix is always stored in column major format!
		 *  @return true if the computation terminated successfully
		 *  @return false otherwise
		 */
		inline bool computeSVD_native()
				throw(Exception::OutOfMemory);

		/** Compute the singular value decomposition of the matrix we are bound to
		 *  using LAPACK.
		 *  NOTE: for reasons of efficiency and compatibility with LAPACK, the resulting
		 *  singular vector matrix is always stored in column major format!
		 *  @return true if the computation terminated successfully
		 *  @return false otherwise
		 */
		inline bool computeSVD_lapack()
				throw(Exception::OutOfMemory);

		/**
		 *  Returns the matrix of left singular vectors. (U in U*S*V^t)
		 */
		inline Matrix<SingularVectorType, StandardTraits>& getLeftSingularVectors();

		/**
		 *  Returns the matrix of left singular vectors. (U in U*S*V^t)
		 */
		inline const Matrix<SingularVectorType, StandardTraits>& getLeftSingularVectors() const;

		/**
		 *  Returns the matrix of right singular vectors. (V^t in U*S*V^t)
		 */
		inline Matrix<SingularVectorType, StandardTraits>& getRightSingularVectors();

		/**
		 *  Returns the matrix of right singular vectors. (V^t in U*S*V^t)
		 */
		inline const Matrix<SingularVectorType, StandardTraits>& getRightSingularVectors() const;

		/**
		 *  Returns the vectors of singular values.
		 */
		inline Vector<SingularValueType>& getSingularValues();

		/**
		 *  Returns the vectors of singular values.
		 */
		inline const Vector<SingularValueType>& getSingularValues() const;

	protected:
		const Matrix<valuetype, mtraits>* matrix_;

		Matrix<SingularVectorType, mtraits> left_singular_vectors_;
		Matrix<SingularVectorType, mtraits> right_singular_vectors_;

		Vector<SingularValueType> singular_values_;
};

}

#endif
