#ifndef BALL_LINALG_SYMMETRICMATRIXCONSTRUCTORS_IC
#define BALL_LINALG_SYMMETRICMATRIXCONSTRUCTORS_IC

namespace BALL {

	template <class valuetype>
	Matrix<valuetype, SymmetricTraits>::Matrix()
		: data_(0),
			row_major_(true),
			n_(0),
			m_(0)
	{
	}

	template <class valuetype> 
	Matrix<valuetype, SymmetricTraits>::Matrix(size_t n, bool row_major)
		: data_((n*(n+1)/2)),
			row_major_(row_major),
			n_(n),
			m_(n)
	{
	}

	template <class valuetype>
	Matrix<valuetype, SymmetricTraits>::Matrix(size_t n, 
																									 const valuetype& initial_value, 
																									 bool row_major)
		: data_((n*(n+1)/2), initial_value),
			row_major_(row_major),
			n_(n),
			m_(n) 
	{
	}

	// TODO: use cblas_xcopy if HAS_BLAS && USE_BLAS
	template <class valuetype>
	Matrix<valuetype, SymmetricTraits>::Matrix(const Matrix<valuetype, SymmetricTraits>& m)
		: data_(m.data_),
			row_major_(m.row_major_),
			n_(m.n_),
			m_(m.m_)
	{
		traits_ = m.traits_;
	}	

	template <class valuetype>
	Matrix<valuetype, SymmetricTraits>::~Matrix()
	{
	}

	// TODO: use cblas_xcopy if HAS_BLAS && USE_BLAS
	template <class valuetype>
	Matrix<valuetype, SymmetricTraits>& Matrix<valuetype, SymmetricTraits>::operator = (const Matrix<valuetype, SymmetricTraits>& m)
	{
		if (this == &m)
			return *this;

	  data_ = m.data_;
	  row_major_ = m.row_major_;
	  n_ = m.n_;
	  m_ = m.m_;
		traits_ = m.traits_;

	  return *this;
	}

	template <class valuetype> template <class mtraits>
	bool Matrix<valuetype, SymmetricTraits>::operator == (const Matrix<valuetype, mtraits>& B) const
	{
		// NOTE: We do not try to be particularly efficient here, since we want this method
		//			 to work reliably for all possible storage type combinations! 
		// TODO: provide more efficient implementations for known combinations like symmetric/symmetric
		if (&B == this)
			return true;

		if ( (n_ != B.n_) || (m_ != B.m_) )
			return false;

		for (size_t i=1; i<=n_; i++)
		{
			for (size_t j=1; j<=m_; j++)
			{
				if ((*this)(i,j) != B(i,j))
					return false;
			}
		}

		return true;
	}

	template <class valuetype> template <class mtraits>
	bool Matrix<valuetype, SymmetricTraits>::operator != (const Matrix<valuetype, mtraits>& B) const
	{
		return !(*this == B);
	}
}

#endif // BALL_LINALG_SYMMETRICMATRIXCONSTRUCTORS_IC
