#ifndef BALL_LINALG_EIGENSOLVER_IC
#define BALL_LINALG_EIGENSOLVER_IC

#include <complex>

namespace BALL {

	typedef std::complex<float>  ComplexFloat;
	typedef std::complex<double> ComplexDouble;

	template <class valuetype, class mtraits>
	EigenSolver<valuetype, mtraits>::EigenSolver()
	: matrix_(0)
	{
	}

	template <class valuetype, class mtraits>
	EigenSolver<valuetype, mtraits>::EigenSolver(const Matrix<valuetype, mtraits>& matrix)
		: matrix_(&matrix)
	{
	}

	template <class valuetype, class mtraits>
	bool EigenSolver<valuetype, mtraits>::setup(const Matrix<valuetype, mtraits>& matrix)
	{
		right_eigenvectors_.clear();
		right_eigenvalues_.clear();
		matrix_ = &matrix;

		return true;
	}

	template <> 
	bool EigenSolver<float, StandardTraits>::solveRightEigenProblem_lapack()
		throw(Exception::OutOfMemory);

	template <> 
	bool EigenSolver<double, StandardTraits>::solveRightEigenProblem_lapack()
		throw(Exception::OutOfMemory);

	template <>
	bool EigenSolver<ComplexFloat, StandardTraits>::solveRightEigenProblem_lapack()
		throw(Exception::OutOfMemory);

	template <>
	bool EigenSolver<ComplexDouble, StandardTraits>::solveRightEigenProblem_lapack()
		throw(Exception::OutOfMemory);

	template <> 
	bool EigenSolver<float, SymmetricTraits>::solveRightEigenProblem_lapack()
		throw(Exception::OutOfMemory);

	template <> 
	bool EigenSolver<double, SymmetricTraits>::solveRightEigenProblem_lapack()
		throw(Exception::OutOfMemory);

	template <class valuetype, class mtraits> 
	bool EigenSolver<valuetype, mtraits>::solveRightEigenProblem_lapack()
		throw(Exception::OutOfMemory)
	{
		std::cerr << "Sorry, no LAPACK-based eigenvalue computation for this valuetype/storage type combination!" << std::endl;
		std::cerr << "Aborting!" << std::endl;

		return false;
	}

	template <class valuetype, class mtraits>
	bool EigenSolver<valuetype, mtraits>::solveRightEigenProblem()
		throw(Exception::OutOfMemory, Exception::MatrixNotQuadratic, Exception::Uninitialized)
	{
		if (!matrix_)
		{
			Exception::Uninitialized e;
			throw (e);
		}

		if (!matrix_->isQuadratic())
		{
			Exception::MatrixNotQuadratic e;
			throw (e);
		}

#ifdef USE_LAPACK
#ifdef DEBUG
		std::cout << "Info: using solveRightEigenProblem_lapack" << std::endl;
#endif
		return solveRightEigenProblem_lapack();
#else
#ifdef DEBUG
		std::cout << "Info: using solveRightEigenProblem_native" << std::endl;
#endif
		return solveRightEigenProblem_native();
#endif
	}

	template <class valuetype, class mtraits>
	bool EigenSolver<valuetype, mtraits>::solveRightEigenProblem_native()
	{
		std::cout << "Error: solveRightEigenProblem_native not implemented yet! Sorry!" << std::endl;
		
		return false;
	}

	template <>
	void EigenSolver<float, StandardTraits>::sort();

	template <>
	void EigenSolver<double, StandardTraits>::sort();

	template <>
	void EigenSolver<ComplexFloat, StandardTraits>::sort();

	template <>
	void EigenSolver<ComplexDouble, StandardTraits>::sort();

	template <>
	void EigenSolver<float, SymmetricTraits>::sort();

	template <>
	void EigenSolver<double, SymmetricTraits>::sort();

	template <class valuetype, class mtraits>
	void EigenSolver<valuetype, mtraits>::sort()
	{
		std::cout << "Error: sorting of eigenvectors not implemented for this storage type!" << std::endl;
		
		return;
	}

	template <class valuetype, class mtraits>
	Matrix<typename EigenSolver<valuetype, mtraits>::EigenVectorType, StandardTraits>& 
		EigenSolver<valuetype, mtraits>::getRightEigenvectors()
	{
		return right_eigenvectors_;
	}

	template <class valuetype, class mtraits>
	const Matrix<typename EigenSolver<valuetype, mtraits>::EigenVectorType, StandardTraits>& 
		EigenSolver<valuetype, mtraits>::getRightEigenvectors() const
	{
		return right_eigenvectors_;
	}

	template <class valuetype, class mtraits>
	Vector<typename EigenSolver<valuetype, mtraits>::EigenValueType>& 
		EigenSolver<valuetype, mtraits>::getRightEigenvalues()
	{
		return right_eigenvalues_;
	}

	template <class valuetype, class mtraits>
	const Vector<typename EigenSolver<valuetype, mtraits>::EigenValueType>& 
		EigenSolver<valuetype, mtraits>::getRightEigenvalues() const
	{
		return right_eigenvalues_;
	}

	template <>
	bool EigenSolver<float, SymmetricTraits>::EigenValueComparator_::operator ()
		(const std::pair<float, Index>& a, const std::pair<float, Index>& b) const;

	template <>
	bool EigenSolver<double, SymmetricTraits>::EigenValueComparator_::operator ()
		(const std::pair<double, Index>& a, const std::pair<double, Index>& b) const;

	template <class valuetype, class mtraits>
	bool EigenSolver<valuetype, mtraits>::EigenValueComparator_::operator () 
		(const std::pair<EigenSolver<valuetype, mtraits>::EigenValueType, Index>& a,
		 const std::pair<EigenSolver<valuetype, mtraits>::EigenValueType, Index>& b) const
	{
		return a.first.real() < b.first.real();
	}

}
#endif
