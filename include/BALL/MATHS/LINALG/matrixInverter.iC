#ifndef BALL_LINALG_MATRIXINVERTER_IC
#define BALL_LINALG_MATRIXINVERTER_IC

#ifndef BALL_LINALG_SVDSOLVER_H
# include <BALL/MATHS/LINALG/SVDSolver.h>
#endif

#ifndef BALL_COMMON_LIMITS_H
# include <BALL/COMMON/limits.h>
#endif

namespace BALL {

	typedef std::complex<float>  ComplexFloat;
	typedef std::complex<double> ComplexDouble;

	template <class valuetype, class mtraits>
	MatrixInverter<valuetype, mtraits>::MatrixInverter()
		: matrix_(0)
	{
	}

	template <class valuetype, class mtraits>
	MatrixInverter<valuetype, mtraits>::MatrixInverter(const Matrix<valuetype, mtraits>& matrix)
		: matrix_(&matrix)
	{
	}

	template <class valuetype, class mtraits>
	bool MatrixInverter<valuetype, mtraits>::setup(const Matrix<valuetype, mtraits>& matrix)
	{
		inverse_.clear();
		pseudo_inverse_.clear();

		matrix_ = &matrix;

		return true;
	}

	template <class valuetype, class mtraits>
	bool MatrixInverter<valuetype, mtraits>::computeInverse()
	{
		typedef SVDSolver<valuetype, mtraits>::SingularValueType  SingularValueType;
		typedef SVDSolver<valuetype, mtraits>::SingularVectorType SingularVectorType;

		if (!matrix_)
		{
			Exception::Uninitialized e;
			throw (e);
		}

		if (!matrix_->isQuadratic())
		{
			Exception::MatrixNotQuadratic e;
			throw (e);
		}

		// SVD decomposes matrix A as:
		//	A = U*S*V.t()
		//	=> A^{-1} = ( U*S*V.t() )^{-1}
		//		= (V.t()).i()*S.i()*U.i()
		//		= V*S.i()*U.t()
		// since the inverse of the eigenvector-Matrices are their transposes.
		// Furthermore, the inverse of S can be obtained as 1/si, where si are the diagonal elements (the eigenvalues).
		// see Press, W.M.(1986), Numerical recipes: The art of scientific computing

		SVDSolver<valuetype> solver(*matrix_);
		bool have_svd = solver.computeSVD();

		if (!have_svd)
		{
			Log.error() << "Could not compute SVD" << std::endl;
			return false;
		}

		Vector<SingularValueType> singular_values = solver.getSingularValues();

		Size n = matrix_->getRowCount();
		Size m = matrix_->getColumnCount();

		Size number_of_singular_values = singular_values.getSize();

		Matrix<SingularValueType, StandardTraits> S_i(m, n);

		SingularValueType max_sv = singular_values(1);
		SingularValueType min_sv = singular_values(number_of_singular_values);

		SingularValueType epsilon = std::numeric_limits<SingularValueType>::epsilon();

		if (min_sv/max_sv < 5*epsilon)
		{
			Exception::MatrixIsSingular e(__FILE__, __LINE__);
			throw(e);
		}

		for(Size i=1; i<=m; i++)
		{
			for(Size j=1; j<=n; j++)
			{
				if (i!=j)
				{
					S_i(i,j)=(SingularValueType)0;
				}
				else
				{
					S_i(i,j) = ((SingularValueType)1)/singular_values(i);
				}
			}
		}

		// getRightSingularVectors() returns V.t() NOT V, so that we need to transpose back to V here !!
		inverse_ = solver.getRightSingularVectors().t()*S_i*solver.getLeftSingularVectors().t();

		// done.
		return true;
	}

	template <class valuetype, class mtraits>
	bool MatrixInverter<valuetype, mtraits>::computePseudoInverse()
	{
		typedef SVDSolver<valuetype, mtraits>::SingularValueType  SingularValueType;
		typedef SVDSolver<valuetype, mtraits>::SingularVectorType SingularVectorType;

		if (!matrix_)
		{
			Exception::Uninitialized e;
			throw (e);
		}

			// SVD decomposes matrix A as:
		//	A = U*S*V.t()
		//	=> A^{-1} = ( U*S*V.t() )^{-1}
		//		= (V.t()).i()*S.i()*U.i()
		//		= V*S.i()*U.t()
		// since the inverse of the eigenvector-Matrices are their transposes.
		// Furthermore, the inverse of S can be obtained as 1/si, where si are the diagonal elements (the eigenvalues).
		// see Press, W.M.(1986), Numerical recipes: The art of scientific computing

		SVDSolver<valuetype> solver(*matrix_);
		bool have_svd = solver.computeSVD();

		if (!have_svd)
		{
			Log.error() << "Could not compute SVD" << std::endl;
			return false;
		}

		Vector<SingularValueType> singular_values = solver.getSingularValues();

		Size n = matrix_->getRowCount();
		Size m = matrix_->getColumnCount();

		Size number_of_singular_values = singular_values.getSize();

		Matrix<SingularValueType, StandardTraits> S_i(m, n);

		SingularValueType max_sv = singular_values(1);
		SingularValueType min_sv = singular_values(number_of_singular_values);

		SingularValueType epsilon = std::numeric_limits<SingularValueType>::epsilon();

		if (min_sv/max_sv < 5*epsilon)
		{
			for(Position a = number_of_singular_values; a>1 ;a--)
			{
				S_i(a,a) = (SingularValueType)0;
				if (singular_values(a-1)/singular_values(1) > 5*epsilon)
					break;
			}
		}

		// getRightSingularVectors() returns V.t() NOT V, so that we need to transpose back to V here !!
		inverse_ = solver.getRightSingularVectors().t()*S_i*solver.getLeftSingularVectors().t();

		// done.
		return true;
	}

	template <class valuetype, class mtraits>
	Matrix<valuetype, StandardTraits>& MatrixInverter<valuetype, mtraits>::getInverse()
	{
		return inverse_;
	}

	template <class valuetype, class mtraits>
	const Matrix<valuetype, StandardTraits>& MatrixInverter<valuetype, mtraits>::getInverse() const
	{
		return inverse_;
	}

	template <class valuetype, class mtraits>
	Matrix<valuetype, StandardTraits>& MatrixInverter<valuetype, mtraits>::getPseudoInverse()
	{
		return pseudo_inverse_;
	}

	template <class valuetype, class mtraits>
	const Matrix<valuetype, StandardTraits>& MatrixInverter<valuetype, mtraits>::getPseudoInverse() const
	{
		return pseudo_inverse_;
	}
}

#endif
