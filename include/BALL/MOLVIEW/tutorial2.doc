/** @name Constructing a dialog for the example application.

		In the section \Ref{Building a bounding box processor.} we have constructed a processor that creates bounding boxes
		for molecular structures. In this section we create a dialog that allows us to
		create bounding boxes in different colors for molecular structures. We use the dialog
		created in the \Ref{VIEW.} tutorial (section \Ref{Construction of a dialog.}) and extend and reimplement certain methods to
		achieve the intended functionality.
		There are only two methods we must change, the method {\em onNotify} and the method
		{\em applyButtonClicked}.

		\begin{verbatim}
    void TestDialog::onNotify(Message *message)
    {
      ...

      if (RTTI::isKindOf<MolecularSelectionMessage>(*message))
        selection_ = (RTTI::castTo<MolecularSelectionMessage>(*message))
                       ->getSelection();
      ...		
    }
		\end{verbatim}

		In the old dialog the method {\em onNotify} catches only \Ref{SelectionMessage} objects.
		Now we want it to catch \Ref{MolecularSelectionMessage} objects that contain the 
		molecular structure selected in the \Ref{MolecularControl}.\\ \\

		The next method that must be changed is the {\em applyButtonClicked}.

		\begin{verbatim}
    void TestDialog::applyButtonClicked()
    {
      if (selection_.empty())
        return;
		\end{verbatim}

		If no selection is available we do nothing.

		\begin{verbatim}
      List<Composite*> update_list;

      GLBoundingBoxModel bboxModel;
      bboxModel.setColor(color_);

      List<Composite*>::ConstIterator list_it = selection_.begin();
      for (; list_it != selection_.end(); ++list_it)
      {
        if (RTTI::isKindOf<Atom>(**list_it))
          continue;
				
        (*list_it)->apply(bboxModel);
				
        update_list.push_back(*list_it);
      }
		\end{verbatim}

		We iterate over the structures in the selection list and start for each
		structure (except atoms) the previously created bounding box processor. Before we
		do this we transfer the color of the preferences tab widget of {\em *this} dialog
		into the processor so that created bounding box has the needed color.
		All processed composite objects are stored in an update list so that those objects
		can be updated later. \\
		{\em Note: } That updating process can not be done in this loop because
		the message sent for the update can change the selection list thus invalidating
		the loop which can lead to segmentation faults. 
			
		\begin{verbatim}
      list_it = update_list.begin();
      for (; list_it != update_list.end(); ++list_it)
      {
        ChangedCompositeMessage change_message;
        change_message.setComposite((*list_it));
        notify_(change_message);
      }
		\end{verbatim}

		For each processed object we sent the message \Ref{ChangedCompositeMessage} so
		that the graphical representation of that \Ref{Composite} object will be regenerated
		when the \Ref{Scene} object is updated next.			

		\begin{verbatim}
      SceneMessage scene_message;
      scene_message.updateOnly();
      notify_(scene_message);
    }
		\end{verbatim}

		To initialize this update we also sent the message \Ref{SceneMessage} with 
		update flag set to redraw all changed objects.\\ \\

		That is all we must do to use our previously defined processor. In the next section
		we will see how to include this dialog into an existing application.
*/


