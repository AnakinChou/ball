// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// 

#ifndef FEATURESEL
#define FEATURESEL

#ifndef MODEL
#include <BALL/QSAR/Model.h>
#endif

#ifndef KMODEL
#include <BALL/QSAR/kernelModel.h>
#endif

#ifndef LMODEL
#include <BALL/QSAR/linearModel.h>
#endif

#ifndef SORTEDLIST
#include <BALL/QSAR/sortedList.h>
#endif

namespace BALL 
{
	namespace QSAR
	{

		class FeatureSelection
		{
			public:
				/** @name Constructors and Destructors
				 */
				//@{
				FeatureSelection(Model& m);
				
				FeatureSelection(KernelModel& m);

				~FeatureSelection();
				//@}
				
				
				/** @name Accessors
				 */
				//@{
				/** set the model, or which feature selection is to be done */
				void setModel(Model& m);
				
				void setModel(KernelModel& km);
	
				/** starts forward selection. \n
				In order to evaluate how much a descriptor increases the accuracy of the model, cross-validation is started in each step using descriptor_matrix from class QSARData as data source.\n
				@param optPar 1 : Model.optimizeParameters() is used to try to find the optimal parameters during *each* step of feature selection. \n
				0: Model.optimizeParameters() is not used during feature selection*/
				void forwardSelection(int k=4, bool optPar=0);
				
				/** starts backward selection. \n
				In order to evaluate how much a descriptor increases the accuracy of the model, cross-validation is started in each step using descriptor_matrix from class QSARData as data source.\n
				@param optPar 1 : Model.optimizeParameters() is used to try to find the optimal parameters during *each* step of feature selection. \n
				0: Model.optimizeParameters() is not used during feature selection*/
				void backwardSelection(int k=4, bool optPar=0);
				
				void stepwiseSelection(int k=4, bool optPar=0);
				
				/** uses the coefficients generated by a linear regression model (LinearModel.training_result) in order to select features.\n
				All descriptors whose coefficients are within 0 +/-  d*stddev are considered to be unimportant and are not selected.\n
				Futhermore, if feature selection has already been done on FeatureSelection->model, only those descriptors that are already part of lm AND of FeatureSelection->model are tested.
				@param act determines which coefficients are to be used, i.e. which column of LinearModel.training_result */
				void implicitSelection(LinearModel& lm, int act=1, double d=1);
				
				/** removes descriptors whose values are 0 in all substances from the list of selected features */
				void removeEmptyDescriptors();
				//@}
	
	
			private:
				
				/** @name Accessors
				 */
				//@{
				void updateWeights(SortedList<unsigned int>& oldDescIDs, SortedList<unsigned int>& newDescIDs, RowVector& oldWeights);
				//@}
				
				
				/** @name Attributes
				 */
				//@{
				/** searches for empty or irrelevant descriptors and returns a sorted list containing their IDs.
				\n If more than one feature selection method is applied, all descriptors that have not been selected by the previous method are considered to be irrelevant.*/
				SortedList<unsigned int>* findIrrelevantDescriptors();
				
				/** pointer to the model, for which feature selection is to be done */
				Model* model_;
				
				/** pointer to KernelModel.weights (if the model to be optimized is a KernelModel) */
				RowVector* weights_;
				
				/** implements forward selection; if stepwise==1, backwardSelection() is called after each forward step, i.e. after adding a feature. */
				void forward(bool stepwise, int k, bool optPar);
				//@}
		};
	}
}


#endif // FEATURESEL
