// $Id: concept.doc,v 1.1 1999/08/26 07:53:16 oliver Exp $

/**@name	Concepts
	This chapter contains all relevant information on 
	the classes representing BALL concepts.
	@nonames
*/
//@{

	//@Include: autoDeletable.h
	//@Include: baseFunctor.h
	//@Include: callback.h
	//@Include: classTest.h
	//@Include: comparator.h
	//@Include: composite.h

	/**	@name Iterators
	*/
	//@{

		//@Include: baseIterator.h
		//@Include: forwardIterator.h
		//@Include: forwardCirculator.h
		//@Include: forwardManipulator.h
		//@Include: reverseBidirectionalIterator.h
		//@Include: reverseRandomAccessIterator.h
		//@Include: bidirectionalIterator.h
		//@Include: bidirectionalManipulator.h
		//@Include: bidirectionalCirculator.h
		//@Include: randomAccessIterator.h

	//@}

	//@Include: notification.h
	//@Include: object.h
	
	/**	@name Object Persistence.
      Ball provides support for the serialization and deserialization of objects and
      their platform-independent storage.\\
			All persistent object have to be derived from PersistentObject.
			The management, serialization, and deserialization is performed by the
			PersistenceManager class. A persistence manager possess an input stream and an output stream 
			({\em persistent streams}).
			It can write objects to the output stream, thereby converting them to a portable format and
			serializing all dependend objects, too. It can also read objects from the input stream,
			create the corresponding objects dynamically and demangle pointers and references.\\
			There are two main problems related with this trivial persistence concept:
			\begin{itemize}
				\item multiple inheritence from a single base class
				\item static members variables
			\end{itemize}
			These problems are inherent problems of C++ and cannot be solved. However, they can be avoided
			in most cases. To circumvent problems related to multiple instances of a common base class
			(which would normally require virtual inheritence - but this does not solve the problem),
			we introduced the model {\em storable}. Storable objects are not derived from PersistentObject,
			but they provide two functions (read/write) to write themselves to a persistent stream and
			to retrieve their contents again.\\
			Static member variables should usually be ignored when  reading/writing persistent objects.
			However, this has to be decided on a case-by-case basis.
  */
  //@{
	
		//@Include: persistentObject.h		
		//@Include: persistenceManager.h		
		//@Include: textPersistenceManager.h		
		//@Include: XDRPersistenceManager.h		
 
	//@}
		
	//@Include: predicate.h
	//@Include: property.h
	//@Include: processor.h
	//@Include: selectable.h
	//@Include: singleton.h
	//@Include: visitor.h

//@}
