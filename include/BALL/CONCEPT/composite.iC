// $Id: composite.iC,v 1.2 1999/09/06 22:20:43 oliver Exp $

BALL_INLINE 
void Composite::set(const Composite& composite, UnaryPredicate<Composite>& predicate)
{
  composite.clone(*this, predicate);
}

BALL_INLINE 
void Composite::set(const Composite& composite, bool deep)
{
	if (deep == true)
	{
		// predicative cloning
		composite.clone(*this, Composite::DEFAULT_UNARY_PREDICATE);

	} else {

		// clear old contents
		destroy();
		
		// copy all remaining attributes
		properties_ = composite.properties_;
		selected_ = composite.selected_;
		contains_selection_ = selected_;
	}
}

BALL_INLINE 
Composite& Composite::operator = (const Composite& composite)
{
  set(composite);

  return *this;
}    

BALL_INLINE 
void Composite::get(Composite& composite, UnaryPredicate<Composite>& predicate) const
{
  composite.set(*this, predicate);
}

BALL_INLINE 
void Composite::get(Composite& composite, bool deep) const
{
  composite.set(*this, deep);
}

BALL_INLINE 
Size Composite::getDegree(void) const
{
  return number_of_children_;
}

BALL_INLINE 
Size Composite::countDescendants(void) const
{
  return (countDescendants_() - 1);
}

BALL_INLINE 
Size Composite::getDepth(void) const
{
  return Composite::getDepth(*this);
}

BALL_INLINE 
Size Composite::getHeight(const Composite &composite)
{
  Size size = 0;

  return composite.getHeight_(size, size);
}

BALL_INLINE 
Size Composite::getHeight(void) const
{
  return Composite::getHeight(*this);
}

BALL_INLINE 
const Composite& Composite::getRoot(void) const
{
  return (const_cast<Composite*>(this)->getRoot());
}

BALL_INLINE 
const Composite* Composite::getLowestCommonAncestor(const Composite &composite) const
{
  return ((Composite *)this)->getLowestCommonAncestor((Composite &)composite);
}

BALL_INLINE 
Composite* Composite::getParent(void)
{
  return parent_;
}

BALL_INLINE 
const Composite* Composite::getParent(void) const
{
  return parent_;
}

BALL_INLINE 
Composite* Composite::getChild(Index index)
{
  if (first_child_ != 0)
  {
    if (index == 0)
    {
      return first_child_;
    } else {
      return first_child_->getSibling(index);
    }
  } else {
    return 0;
  }
}

BALL_INLINE 
const Composite* Composite::getChild(Index index) const
{
  return ((Composite *)this)->getChild(index);
}

BALL_INLINE 
const Composite* Composite::getSibling(Index index) const
{
  return ((Composite *)this)->getSibling(index);
}

BALL_INLINE 
Composite* Composite::getFirstChild(void)
{
  return first_child_;
}

BALL_INLINE 
const Composite* Composite::getFirstChild(void) const
{
  return first_child_;
}

BALL_INLINE 
Composite* Composite::getLastChild(void)
{
  return last_child_;
}

BALL_INLINE 
const Composite* Composite::getLastChild(void) const
{
  return last_child_;
}

BALL_INLINE 
void Composite::expand(void)
{
  BALL_BIT_CLEAR(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
void Composite::collapse(void)
{
  BALL_BIT_SET(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
void Composite::replace(Composite& composite)
{
  if (parent_ != 0)
  {
    insertBefore(composite);

    parent_->removeChild(*this);
  }
}

BALL_INLINE 
bool Composite::isExpanded(void) const
{
  return (bool)BALL_BIT_IS_CLEARED(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
bool Composite::isCollapsed(void) const
{
  return (bool)BALL_BIT_IS_SET(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
bool Composite::isEmpty(void) const
{
  return (bool)(number_of_children_ == 0);
}

BALL_INLINE 
bool Composite::isFree(void) const
{
  return (bool)(parent_ == 0);
}

BALL_INLINE 
bool Composite::isRoot(void) const
{
  return (bool)(parent_ == 0);
}
  
BALL_INLINE 
bool Composite::isRootOf(const Composite& composite) const
{
  return (bool)(parent_ == 0 && isAncestorOf(composite) == true);
}
  
BALL_INLINE 
bool Composite::isInterior(void) const
{
  return (bool)(parent_ != 0 && first_child_ != 0);
}

BALL_INLINE 
bool Composite::isInteriorOf(const Composite &composite) const
{
  return (bool)(parent_ != 0 && first_child_ != 0 && isDescendantOf(composite) == true);
}

BALL_INLINE 
bool Composite::isLeaf(void) const
{
  return (bool)(first_child_ == 0);
}

BALL_INLINE 
bool Composite::isLeafOf(const Composite &composite) const
{
  return (bool)(first_child_ == 0 && isDescendantOf(composite) == true);
}

BALL_INLINE 
bool Composite::hasChild(void) const
{
  return (bool)(first_child_ != 0);
}

BALL_INLINE 
bool Composite::isChild(void) const
{
  return (bool)(parent_ != 0);
}

BALL_INLINE 
bool Composite::isChildOf(const Composite &composite) const
{
  return (bool)(parent_ == &composite);
}

BALL_INLINE 
bool Composite::isFirstChild(void) const
{
  return (bool)(parent_ != 0 && parent_->first_child_ == this);
}

BALL_INLINE 
bool Composite::isFirstChildOf(const Composite &composite) const
{
  return (bool)(composite.first_child_ == this);
}

BALL_INLINE 
bool Composite::isLastChild(void) const
{
  return (bool)(parent_ != 0 && parent_->last_child_ == this);
}

BALL_INLINE 
bool Composite::isLastChildOf(const Composite &composite) const
{
  return (bool)(composite.last_child_ == this);
}

BALL_INLINE 
bool Composite::hasParent(void) const
{
  return (bool)(parent_ != 0);
}

BALL_INLINE 
bool Composite::isParent(void) const
{
  return (bool)(first_child_ != 0);
}

BALL_INLINE 
bool Composite::isParentOf(const Composite &composite) const
{
  return (bool)(composite.parent_ == this);
}

BALL_INLINE 
bool Composite::hasSibling(void) const
{
  return (bool)(parent_ != 0 && parent_->number_of_children_ > 1);
}

BALL_INLINE 
bool Composite::isSibling(void) const
{
  return (bool)(parent_ != 0 && parent_->number_of_children_ > 1);
}

BALL_INLINE 
bool Composite::isSiblingOf(const Composite &composite) const
{
  return (bool)(composite.parent_ == parent_);
}

BALL_INLINE 
bool Composite::hasPreviousSibling(void) const
{
  return (bool)(previous_ != 0);
}

BALL_INLINE 
bool Composite::isPreviousSibling(void) const
{
  return (bool)(next_ != 0);
}

BALL_INLINE 
bool Composite::isPreviousSiblingOf(const Composite &composite) const
{
  return (bool)(next_ == &composite);
}

BALL_INLINE 
bool Composite::hasNextSibling(void) const
{
  return (bool)(next_ != 0);
}

BALL_INLINE 
bool Composite::isNextSibling(void) const
{
  return (bool)(previous_ != 0);
}

BALL_INLINE 
bool Composite::isNextSiblingOf(const Composite &composite) const
{
  return (bool)(previous_ == &composite);
}

BALL_INLINE 
bool Composite::hasPreceedingSibling(void) const
{
  return (bool)(previous_ != 0);
}

BALL_INLINE 
bool Composite::isPreceedingSibling(void) const
{
  return (bool)(next_ != 0);
}

BALL_INLINE 
bool Composite::hasSucceedingSibling(void) const
{
  return (bool)(next_ != 0);
}

BALL_INLINE 
bool Composite::isSucceedingSibling(void) const
{
  return (bool)(previous_ != 0);
}

BALL_INLINE 
bool Composite::hasDescendant(void) const
{
  return (bool)(first_child_ != 0);
}
  
BALL_INLINE 
bool Composite::isDescendant(void) const
{
  return (bool)(parent_ != 0);
}
  
BALL_INLINE 
bool Composite::hasAnyAncestor(void) const
{
  return (bool)(parent_ != 0);
}

BALL_INLINE 
bool Composite::isAncestor(void) const
{
  return (bool)(first_child_ != 0);
}

BALL_INLINE 
bool Composite::isRelatedWith(const Composite &composite) const
{
  return (bool)(&composite == this
								|| composite.isAncestorOf(*this)
								|| this->isAncestorOf(composite));
}
  
BALL_INLINE
bool Composite::containsSelection() const
{
	return (contains_selection_);
}

BALL_INLINE 
void Composite::host(Visitor<Composite>& visitor)
{
  visitor.visit(*this);
}

BALL_INLINE 
bool Composite::applyPreorderNostart_(UnaryProcessor<Composite>& processor)
{
  Processor::Result result = processor(*this);
	bool return_value;

  if (result <= Processor::BREAK)
	{
		return_value = (result == Processor::BREAK) ? true : false;
	} else {
		return_value =  applyDescendantPreorderNostart_(processor);
	}
	
	return return_value;
}

BALL_INLINE 
bool Composite::applyDescendant(UnaryProcessor<Composite>& processor)
{
  return applyDescendantPreorder(processor);
}

BALL_INLINE
bool Composite::applyPreorder(UnaryProcessor<Composite>& processor)
{
	return processor.start() && applyPreorderNostart_(processor) && processor.finish();
}

BALL_INLINE 
bool Composite::applyPostorder(UnaryProcessor<Composite>& processor)
{
	bool return_value = false;
	if (processor.start() != false)
	{
		if (applyDescendantPostorderNostart_(processor) == true
				&& processor(*this) < Processor::BREAK)
		{
			return_value = processor.finish();
		} 
	}
	
	return return_value;
}

BALL_INLINE 
bool Composite::apply(UnaryProcessor<Composite>& processor)
{
  return processor.start() && applyPreorderNostart_(processor) && processor.finish();
}
