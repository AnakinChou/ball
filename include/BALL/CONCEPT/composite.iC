// $Id: composite.iC,v 1.4 1999/09/07 19:35:33 oliver Exp $

BALL_INLINE 
void Composite::set(const Composite& composite, UnaryPredicate<Composite>& predicate)
{
  composite.clone(*this, predicate);
}

BALL_INLINE 
void Composite::set(const Composite& composite, bool deep)
{
	if (deep == true)
	{
		// predicative cloning
		composite.clone(*this, Composite::DEFAULT_UNARY_PREDICATE);

	} else {

		// clear old contents
		destroy();
		
		// copy all remaining attributes
		properties_ = composite.properties_;
		selected_ = composite.selected_;
		contains_selection_ = selected_;
	}
}

BALL_INLINE 
Composite& Composite::operator = (const Composite& composite)
{
  set(composite);

  return *this;
}    

BALL_INLINE 
void Composite::get(Composite& composite, UnaryPredicate<Composite>& predicate) const
{
  composite.set(*this, predicate);
}

BALL_INLINE 
void Composite::get(Composite& composite, bool deep) const
{
  composite.set(*this, deep);
}

BALL_INLINE 
Size Composite::getDegree() const
{
  return number_of_children_;
}

BALL_INLINE 
Size Composite::countDescendants() const
{
  return (countDescendants_() - 1);
}

BALL_INLINE 
Size Composite::getDepth() const
{
  return Composite::getDepth(*this);
}

BALL_INLINE 
Size Composite::getHeight() const
{
  Size size = 0;

	// if there are children, determine the maximum height
	if (first_child_ != 0)
	{	
	  return getHeight_(size, size);
	} else {
		// otherwise we are at height 0
		return 0;
	}
}

BALL_INLINE 
const Composite& Composite::getRoot() const
{
  return (const_cast<Composite*>(this)->getRoot());
}

BALL_INLINE 
const Composite* Composite::getLowestCommonAncestor(const Composite &composite) const
{
  return ((Composite *)this)->getLowestCommonAncestor((Composite &)composite);
}

BALL_INLINE 
Composite* Composite::getParent()
{
  return parent_;
}

BALL_INLINE 
const Composite* Composite::getParent() const
{
  return parent_;
}

BALL_INLINE 
Composite* Composite::getChild(Index index)
{
  if (first_child_ != 0)
  {
    if (index == 0)
    {
      return first_child_;
    } else {
      return first_child_->getSibling(index);
    }
  } else {
    return 0;
  }
}

BALL_INLINE 
const Composite* Composite::getChild(Index index) const
{
  return ((Composite *)this)->getChild(index);
}

BALL_INLINE 
const Composite* Composite::getSibling(Index index) const
{
  return ((Composite *)this)->getSibling(index);
}

BALL_INLINE 
Composite* Composite::getFirstChild()
{
  return first_child_;
}

BALL_INLINE 
const Composite* Composite::getFirstChild() const
{
  return first_child_;
}

BALL_INLINE 
Composite* Composite::getLastChild()
{
  return last_child_;
}

BALL_INLINE 
const Composite* Composite::getLastChild() const
{
  return last_child_;
}

BALL_INLINE 
void Composite::expand()
{
  BALL_BIT_CLEAR(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
void Composite::collapse()
{
  BALL_BIT_SET(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
void Composite::replace(Composite& composite)
{
  if (parent_ != 0)
  {
    insertBefore(composite);

    parent_->removeChild(*this);
  }
}

BALL_INLINE 
bool Composite::isExpanded() const
{
  return BALL_BIT_IS_CLEARED(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
bool Composite::isCollapsed() const
{
  return BALL_BIT_IS_SET(properties_, PROPERTY__COLLAPSED_);
}

BALL_INLINE 
bool Composite::isEmpty() const
{
  return (number_of_children_ == 0);
}

BALL_INLINE 
bool Composite::isRoot() const
{
  return (parent_ == 0);
}
  
BALL_INLINE 
bool Composite::isRootOf(const Composite& composite) const
{
  return ((parent_ == 0) && (isAncestorOf(composite) == true) || (&composite == this));
}
  
BALL_INLINE 
bool Composite::isInterior() const
{
  return (parent_ != 0 && first_child_ != 0);
}

BALL_INLINE 
bool Composite::hasChild() const
{
  return (first_child_ != 0);
}

BALL_INLINE 
bool Composite::isChild() const
{
  return (parent_ != 0);
}

BALL_INLINE 
bool Composite::isChildOf(const Composite &composite) const
{
  return (parent_ == &composite);
}

BALL_INLINE 
bool Composite::isFirstChild() const
{
  return (parent_ != 0 && parent_->first_child_ == this);
}

BALL_INLINE 
bool Composite::isFirstChildOf(const Composite &composite) const
{
  return (composite.first_child_ == this);
}

BALL_INLINE 
bool Composite::isLastChild() const
{
  return (parent_ != 0 && parent_->last_child_ == this);
}

BALL_INLINE 
bool Composite::isLastChildOf(const Composite &composite) const
{
  return (composite.last_child_ == this);
}

BALL_INLINE 
bool Composite::hasParent() const
{
  return (parent_ != 0);
}

BALL_INLINE 
bool Composite::isParent() const
{
  return (first_child_ != 0);
}

BALL_INLINE 
bool Composite::isParentOf(const Composite &composite) const
{
  return (composite.parent_ == this);
}

BALL_INLINE 
bool Composite::hasSibling() const
{
  return (parent_ != 0 && parent_->number_of_children_ > 1);
}

BALL_INLINE 
bool Composite::isSiblingOf(const Composite &composite) const
{
  return (composite.parent_ == parent_);
}

BALL_INLINE 
bool Composite::hasPreviousSibling() const
{
  return (previous_ != 0);
}

BALL_INLINE 
bool Composite::isPreviousSiblingOf(const Composite &composite) const
{
  return (next_ == &composite);
}

BALL_INLINE 
bool Composite::hasNextSibling() const
{
  return (next_ != 0);
}

BALL_INLINE 
bool Composite::isNextSiblingOf(const Composite &composite) const
{
  return (previous_ == &composite);
}

BALL_INLINE 
bool Composite::hasDescendant() const
{
  return (first_child_ != 0);
}
  
BALL_INLINE 
bool Composite::isDescendant() const
{
  return (parent_ != 0);
}
  
BALL_INLINE 
bool Composite::hasAnyAncestor() const
{
  return (parent_ != 0);
}

BALL_INLINE 
bool Composite::isAncestor() const
{
  return (first_child_ != 0);
}

BALL_INLINE 
bool Composite::isRelatedWith(const Composite &composite) const
{
  return ((&composite == this)
					|| composite.isAncestorOf(*this)
					|| this->isAncestorOf(composite));
}
  
BALL_INLINE
bool Composite::containsSelection() const
{
	return (contains_selection_);
}

BALL_INLINE 
void Composite::host(Visitor<Composite>& visitor)
{
  visitor.visit(*this);
}

BALL_INLINE 
bool Composite::applyPreorderNostart_(UnaryProcessor<Composite>& processor)
{
  Processor::Result result = processor(*this);
	bool return_value;

  if (result <= Processor::BREAK)
	{
		return_value = (result == Processor::BREAK) ? true : false;
	} else {
		return_value =  applyDescendantPreorderNostart_(processor);
	}
	
	return return_value;
}

BALL_INLINE 
bool Composite::applyDescendant(UnaryProcessor<Composite>& processor)
{
  return applyDescendantPreorder(processor);
}

BALL_INLINE
bool Composite::applyPreorder(UnaryProcessor<Composite>& processor)
{
	return processor.start() && applyPreorderNostart_(processor) && processor.finish();
}

BALL_INLINE 
bool Composite::applyPostorder(UnaryProcessor<Composite>& processor)
{
	bool return_value = false;
	if (processor.start() != false)
	{
		if (applyDescendantPostorderNostart_(processor) == true
				&& processor(*this) < Processor::BREAK)
		{
			return_value = processor.finish();
		} 
	}
	
	return return_value;
}

BALL_INLINE 
bool Composite::apply(UnaryProcessor<Composite>& processor)
{
  return processor.start() && applyPreorderNostart_(processor) && processor.finish();
}
