// $Id: logStream.iC,v 1.5 2000/05/29 23:42:49 amoll Exp $

BALL_INLINE
int LogStreamBuf::overflow(const int& c)
{
	sync();
	return ::std::streambuf::overflow(c);
}
		
BALL_INLINE
LogStreamBuf* LogStream::rdbuf() 
{
	return (LogStreamBuf*)std::ios::rdbuf();
}

BALL_INLINE
LogStreamBuf* LogStream::operator -> () 
{
	return rdbuf();
}

BALL_INLINE
void LogStream::setLevel(const int& level) 
{
	if (rdbuf() == 0)
	{
		return;
	}

	// set the new level
	rdbuf()->level_ = level;

	// set tmp_level_, too - to otherwise the
	// new level would take effect in the line after 
	// the next!
	rdbuf()->tmp_level_ = level;
}

BALL_INLINE
int LogStream::getLevel() 
{
	if (rdbuf() != 0)
	{
		return rdbuf()->level_;
	} else {
		return 0;
	}
}

BALL_INLINE
LogStream& LogStream::level(const int& n) 
{
	// set the temporary level 
	// will be reset by sync(), i.e. at the end of the next line
	if (rdbuf() != 0)
	{
		rdbuf()->tmp_level_ = n;
	}

	return *this;
}

BALL_INLINE
LogStream& LogStream::error(const int& n)
{
	// set the temporary level to ERROR
	// will be reset by sync(), i.e. at the end of the next line
	if (rdbuf() != 0)
	{
		rdbuf()->tmp_level_ = ERROR + n;
	}

	return *this;
}

BALL_INLINE
LogStream& LogStream::warn(const int& n)
{
	// set the temporary level to WARNING
	// will be reset by sync(), i.e. at the end of the next line
	if (rdbuf() != 0)
	{
		rdbuf()->tmp_level_ = WARNING + n;
	}

	return *this;
}

BALL_INLINE
LogStream& LogStream::info(const int& n)
{
	// set the temporary level to INFORMATION
	// will be reset by sync(), i.e. at the end of the next line
	if (rdbuf() != 0)
	{
		rdbuf()->tmp_level_ = INFORMATION + n;
	}

	return *this;
}


